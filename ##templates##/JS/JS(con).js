/*
https://learn.javascript.ru/
Кратко: https://developer.mozilla.org/ru/docs/Web/JavaScript/Language_overview

//*Числа =============================================================================================//
Math.ceil(5.8)									Округлить вверх
Math.floor(5.8)									Округлить вниз
Math.round(5.8)								 	Округлить до целого
Math.trunc()										Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
Math.random()										Рандом
Math.max(5, 85, -49); 					Ищет максимум
Math.min(5, 85, -49); 					Ищет минимум
Math.pow(5, 8);									Возвести в степень
Math.sqrt(PositiveBumber)				возвращает квадратный корень числа
1.005 + Number.EPSILON					Компенсировать погрешности
Num.toFixed(1); 								кол-во знаков после запятой (как Math.round). //?Возвращает строку!!!
Num.toString()									Привести к строке
Number(string)									Привести к числу. Или +"356"
parseInt(Number) 								вернет ЦЕЛОЕ число из строки до текста. В качастве второго аргумента - система исчисления!!!
parseFloat(Number) 							вернет число из строки до текста c цифрами после запятой. В качастве второго аргумента - система исчисления!!!
isNaN(Number)										проверка на NaN
Number.isNaN(Number)						строгая проверка на NaN
Number.isInteger()							проверка на целое число
Number.isFinite(value)					преобразует аргумент в число и проверяет, что оно не является NaN/Infinity/-Infinity

Number.prototype (Number.prototype.constructor) - методы на уровне прототипа и конструктора
Для явного преобразования к числу можно использовать + или Number().
Если строка не является в точности числом, то результат будет NaN.
Для этого есть parseInt и parseFloat.

Проверки NaN == NaN и NaN === NaN в качестве значения вернут false.
Следовательно, для проверки нужна функция isNaN. (https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/isNaN)

Методы Number.isNaN и Number.isFinite – это более «строгие» версии функций isNaN и isFinite.
Они не преобразуют аргумент в число, а наоборот – первым делом проверяют,
	является ли аргумент числом (принадлежит ли он к типу number).
Number.isNaN(value) возвращает true только в том случае,
	если аргумент принадлежит к типу number и является NaN.
	Во всех остальных случаях возвращает false.

Чтобы писать числа с большим количеством нулей:
Используйте краткую форму записи чисел – "e", с указанным количеством нулей.
	Например: 123e6 это 123 с 6-ю нулями 123000000.
Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей.
	Например: 123e-6 это 0.000123 (123 миллионных).

Для дробей:
Используйте округления Math.floor, Math.ceil, Math.trunc, Math.round или num.toFixed(precision).
Помните, что при работе с дробями происходит потеря точности.

Если надо округлить число до n-ого количества цифр в дробной части есть два пути решения:
	1. Умножить и разделить.
	2. Метод toFixed(n) округляет число до n знаков после запятой и возвращает строковое представление результата.
		Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу Math.round

//* Строки =============================================================================================//
string.lenght 										возвращает длину строки
string.charAt(5) 									возвращает символ под индексом 5
string.substring(start, end) 			возвращает от start до end. Если start больше end, то метод substring сработает так, как если бы аргументы были поменяны местами.
string.slice(-10) 								возвращает от start до (не включая) end (как и substring, но может и с отрицательными позициями)
string.substr(14, 4) 							возвращает как и substring, 14 - старт, 4 кол-во символов. Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца
string.indexOf('word') 						ищет позицию слова или символы в строке. Необязательный второй аргумент позволяет начать поиск с определённой позиции.
string.lastIndexOf('word') 				ищет позицию слова или символы в строке с конца
string.replace('word', 'another word') меняет строку (не перезаписывая) 'word' - что меняем, 'another word' - на что меняем. Только первое совпадение
string.replaceAll									меняет все совпадения
string.includes('ord') 						возвращает true or false
string.split(' ') 								принимает разделитель и разбивает строку на масив
arr.join(' ') 										создаёт строку из элементов arr, вставляя ' ' между ними
string.toUpperCase() 							приведение к верхнему регистру
string.toLowerCase() 							приведение к нижнему регистру
notString.toString()							Привести к строке. Или (345 + ""). //? В качастве аргумента - система исчисления!!!
'*'.repeat(4)											Повторить символ (4) раза
string.startsWith(str) 						проверяет начинается ли строка определённой строкой
string.endsWith(str)							проверяет заканчивается ли строка определённой строкой
string.trim()											обрезает пробелы (trimStart - в начале, trimEnd - в конце)
Boolean('string or expression')		приведение к булевому значению или !!('string or expression')
str.padStart(targetLength [, padString])	дополняет начало/конец текущей строки другой строкой (при необходимости несколько раз) до заданной длины.
																	Первым параметром в методе указываем желаемую длину строки, а вторым необязательным - строку, которой она будет заполнена.

Для получения символа используйте [] или метод at.
str.length-1 or str.at(-1)
Квадратные скобки всегда возвращают undefined для отрицательных индексов

Для получения подстроки используйте slice или substring.
Для поиска подстроки используйте indexOf или includes/startsWith/endsWith, когда надо только проверить, есть ли вхождение.
indexOf стоит использовать тогда когда нам нужна позиция найденой подстроки.
В остальных случаях удобнее использовать includes

Чтобы сравнить строки с учётом правил языка, используйте localeCompare.
Если надо вызвать метод toString непосредственно на числе, надо поставить две точки .. после числа.
Mожно перебрать строку посимвольно, используя for..of
Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его.

//* Объекты =================================================================================================//
? Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
Объекты присваиваются и копируются по ссылке.
Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) на это значение.
Таким образом, копирование такой переменной или передача её в качестве аргумента функции копирует эту ссылку, а не сам объект.
Все операции с использованием скопированных ссылок (например, добавление/удаление свойств) выполняются с одним и тем же объектом.
Чтобы создать «реальную копию» (клон), мы можем использовать Object.assign для так называемой «поверхностной копии»
(вложенные объекты копируются по ссылке) или функцию «глубокого клонирования», такую как _.cloneDeep(obj).

Свойства упорядочены особым образом:
	свойства с целочисленными ключами сортируются по возрастанию
	остальные располагаются в порядке создания

obj.newKey = 'new prop'							Добавить ключ newKey со свойством 'new prop'
delete object.key										Удалить ключ и свойство
obj.hasOwnProperty('key')						Возвращает true, только если данное свойство присутствует в объекте. Не проверяет существование свойств в цепочке прототипов объекта.
'key' in object											Возвращает true, только если данное свойство присутствует в объекте или его прототипе. Он предпочтительней когда неизвестен тип данных (null, undefined)
JSON.stringify(Object)							Преобразовать в строку (не конвертирует значения undefined (с null работает))
JSON.parse(String)									Преобразовать в объект
Object.keys(user)										Получить ключи в массив (первого уровня вложенности)
Object.values(user)									Получить значения в массив (первого уровня вложенности)
Object.entries(user)								Получить значения и ключи в массив масивов
Object.assign({}, user)							Копирование объекта (не глубокое!!!). Или const anotherCopy = {...user,}
user?.address?.street								Опциональная цепочка (проверяет наличие ключа или возвращает undefinded) (let html = document.querySelector('.elem')?.innerHTML;)

?Object.assign(dest, [src1, src2, src3...])
Первый аргумент dest — целевой объект.
Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest.
Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
Возвращает объект dest. Перезаписывает dest
Примитивы будут обёрнуты, а null и undefined - проигнорированы.

? Пройтись по ключам и вставить в переменную i  (for..in) (!Не использоваь (for..in) на массивах)
for (let i in user) { // положет ключи в i
	console.log(i)						ключ
	console.log(user[i])			значение
}

? Вывести все ключи и значения циклом (Конвертировать объект в масив и работаем как с масивом)
const entries = Object.entries(user);
for (let i = 0; i < entries.length; i++) {
	const entry = entries[i];
	const key = entry[0];
	const value = entry[1];
	console.log(key, value);
}

?? Проверка существования свойства, оператор «in»
("age" in user) Слева от оператора in должно быть имя свойства.
Обычно это строка в кавычках.
Если мы опускаем кавычки, это значит, что мы указываем переменную,
в которой находится имя свойства.

//* Массивы ==================================================================================================//
? Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.
Мы можем получить элемент по его индексу, например arr[0].
Также мы можем использовать метод at(i) для отрицательных значений i, он отступает от конца массива.
В остальном он работает так же, как arr[i], если i >= 0.
length это не количество элементов массива, а наибольший цифровой индекс плюс один.
Самый простой способ очистить массив – это arr.length = 0;.
delete не удаляет елемент массива полностью (остается , ,) Нужен splice()
typeof не может отличить простой объект от массива
Array.isArray(value) возвращает true, если value массив, и false, если нет.

? Мы можем использовать массив как двустороннюю очередь, используя следующие операции:
push(...items)												добавляет items в конец массива.
pop()																	удаляет элемент в конце массива и возвращает его.
unshift(...items)											добавляет items в начало массива.
shift()																удаляет элемент в начале массива и возвращает его.

splice(pos, deleteCount, ...items)		Начиная с индекса pos удаляет deleteCount элементов и вставляет items.
																			Возвращает массив из удалённых элементов. Меняет массив
slice(start, end)											создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
																			Не изменяет исходный массив. Без аргументов создаёт копию (копирует по ссылке). Использоваться для преобразования массивоподобных объектов
arr1.concat(arr2, ...items)						возвращает новый массив: копирует все члены текущего массива и добавляет к нему items
																			Если какой-то из items является массивом, тогда берутся его элементы. Не изменяет данный массив или любой из массивов

? Для поиска среди элементов:
indexOf/lastIndexOf(item, pos)				ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено. .lastIndexOf() Ищет последнее вхождение элемента в массиве
includes(value)												возвращает true, если в массиве имеется элемент value, в противном случае false. Работает только для простых данных
find/filter(func)											фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true. Если нет - undefined
findIndex/findLastIndex 							похож на find, но возвращает индекс вместо значения / проверяет с конца
some(func)														фильтрует элементы через функцию и вернет true или false.
																			возвращает true, если функция проверки правдива хотя бы для одного элемента массива. Иначе, false.

? Для перебора элементов
forEach(func)													вызывает func для каждого элемента. Ничего не возвращает (нет continue и break).
for (let i=0; i<arr.length; i++)			работает быстрее всего, совместим со старыми браузерами.
for (let item of arr)									современный синтаксис только для значений элементов (к индексам нет доступа).Не работает с объектами.
for (let i in arr)										для объектов. Никогда не используйте для массивов!

? Для преобразования массива:
arr.map(func)													создаёт новый массив из результатов вызова func для каждого элемента.
arr.sort(func)												сортирует массив «на месте», а потом возвращает его.
arr.reverse()													«на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
string.split(' ')											разбивает строку на массив по заданному разделителю (как join, только в другую сторону)
arr.join(' ')													склеивает массив в строку по заданному разделителю (как split, только в другую сторону)
reduce/reduceRight(func, initial)			вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
arr.flat()														преобразует вложенные массивы в один. arr.flat(2) преобразовать вторую вложенность arr.flat(infinity)
																			удаляет пустые слоты из массива

Array.isArray(arr) проверяет, является ли arr массивом.
методы sort, reverse и splice изменяют исходный массив.

? Метод sort()
Сортирует массив на месте, меняя в нём порядок элементов.
Он также возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.
По умолчанию элементы сортируются как строки.

arr.sort((a, b) => a - b); Сортирует по возрастанию
animals.sort((a, b) => a.localeCompare(b)); Для массива строк

? Метод map()
Позволяет трансформировать один массив в другой при помощи функций-колбэка.
Переданная функция будет вызвана для каждого элемента массива по порядку.
Из результатов вызова функции будет собран новый массив. Колличество новых элементов будет равно кол. старых эл. (изменить нельзя!!!)
При работе с map() необходимо возвращать значение из функции-колбэка.
Если не вернуть значение — например, забыв обработать какую-то ветку условия, то в итоговом массиве будет undefined
В отличии от forEach возвращает результат вызова

	const arr = ['hi', 'hello']
	const newArr = arr.map(function (element) {
		return element.length		// Получаем новый массив из длин элементов оригинального [2, 5]
	})

? Метод filter()
Позволяет получить новый массив, отфильтровав элементы с помощью переданной колбэк-функции.
Колбэк-функция будет вызвана для каждого элемента массива
	и по результату функции примет решение включать этот элемент в новый массив или нет.
Аналогично методу .forEach(), методу .filter() необходимо передать аргументом функцию.
Главное отличие — функция должна возвращать boolean, т. е. результатом должен быть true или false. Такие функции называют предикатами.
От результата выполнения функции зависит, попадёт ли элемент в итоговый массив: true — элемент попадёт в итоговый массив. false — нет.
filter в опличии от map не меняет структуру массива, а меняет колличество элементов!!!
filter() возвращает новый массив, при этом исходный массив никак не изменится.
Если явно не указать return, то метод вернет пустой массив.

? Метод find()
В отличии от filter() вернёт первый найденный в массиве элемент, который подходит под условие в переданной колбэк-функции.
Если в массиве не найдётся ни одного подходящего элемента, то вернётся значение undefined.

? Метод some()
Позволяет узнать, есть ли в массиве хотя бы один элемент, удовлетворяющий условию в функции-колбэке.
Результатом вызова метода some() будет boolean-значение true или false.
Если ни один элемент в массиве не удовлетворит условию, то результат будет false.

? Метод reduce()
Позволяет превратить массив в любой другой тип данных с помощью переданной функции-колбэка и начального значения.
Функция-колбэк будет вызвана для каждого элемента массива, и всегда должна возвращать результат.
Главной особенностью reduce(), которую важно запомнить, является наличие аккумулятора.

	const myArray = [1, 2, 3, 4, 5, 6, 7]
	const sumOfNumbers = myArray.reduce(
		/ acc - аккумулятор, element - элемент массива
		function (acc, element) {
			return acc + element
		},
		0 // Начальное значение аккумулятора
	)

? Array.from
Array.from(obj[, mapFn, thisArg]) создаёт настоящий Array из итерируемого объекта или псевдомассива obj,
и затем мы можем применять к нему методы массивов.
Необязательные аргументы mapFn и thisArg позволяют применять функцию с задаваемым контекстом к каждому элементу.

	const linkElements = document.getElementsByTagName('a')
	const arrLinks = Array.from(linkElements, function(a) {
		return a.href
	})

? Мутация массивов (https://teletype.in/@budnifronta/S9toCiHnJpv)
Методы массива, которые изменяют массив, к которому они обращаются:
	pop() push() shift() unshift() reverse() sort() splice()
Методы, которые не изменяют исходный массив, а возвращают новый массив:
	slice() concat() map() filter()

//* Условное ветвление: if, '?' switch-case ============================================================================//
Иногда нам нужно выполнить различные действия в зависимости от условий.
Для этого мы можем использовать инструкцию if и условный оператор ?

? if else
if (age < 3) {
	message = 'Здравствуй, малыш!';
} else if (age < 18) {
	message = 'Привет!';
} else if (age < 100) {
	message = 'Здравствуйте!';
} else {
	message = 'Какой необычный возраст!';
}

? Оператор „?“
Синтаксис:
let result = условие ? значение1 : значение2;

let age = prompt('Возраст?', 18);
let message = (age < 3) ? 'Здравствуй, малыш!' :
	(age < 18) ? 'Привет!' :
	(age < 100) ? 'Здравствуйте!' :
	'Какой необычный возраст!';
alert( message );

Первый знак вопроса проверяет age < 3.
Если верно – возвращает 'Здравствуй, малыш!'. В противном случае, проверяет выражение после двоеточия „:“, вычисляет age < 18.
Если это верно – возвращает 'Привет!'. В противном случае, проверяет выражение после следующего двоеточия „:“, вычисляет age < 100.
Если это верно – возвращает 'Здравствуйте!'. В противном случае, возвращает выражение после последнего двоеточия – 'Какой необычный возраст!'.

? switch case
Проверка на равенство всегда строгая.
Значения должны быть одного типа, чтобы выполнялось равенство.
Если в свитче меньше трёх кейсов, то if...else будет читаться проще.
switch для точных значений.
Логические операторы стоит использовать в if - это правильнее и в разы быстрее.

switch (name) {
	case "Alex":
		console.log(Hi Alex)
		break
	case "John":
		console.log(Hi John)
		break
	default:
	 console.log(Hi User)
}

* Циклы while и for ======================================================================================//
? while – Проверяет условие перед каждой итерацией.
while (condition) {
	код, также называемый "телом цикла"
}

? do..while – Проверяет условие после каждой итерации.
do {
	тело цикла
} while (condition);

? for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.
Чтобы организовать бесконечный цикл, используют конструкцию while (true).
При этом он, как и любой другой цикл, может быть прерван директивой break.
for (начало; условие; шаг) {
	тело цикла ...
}

Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву continue.
Директива break полностью прекращает выполнение цикла и передаёт управление на строку за его телом.
Обе этих директивы поддерживают метки, которые ставятся перед циклом.

Метки – единственный способ для break/continue выйти за пределы текущего цикла, повлиять на выполнение внешнего.
Заметим, что метки не позволяют прыгнуть в произвольное место кода, в JavaScript нет такой возможности.

?Цикл "for..in"
Для перебора всех свойств объекта используется цикл for..in.

let user = {
	name: "John",
	age: 30,
	isAdmin: true
};

for (let key in user) {
ключи
	alert( key );  // name, age, isAdmin
значения ключей
	alert( user[key] ); // John, 30, true
}

* Функции ================================================================================================//
Параметр – это переменная, указанная в круглых скобках в объявлении функции.
Аргумент – это значение, которое передаётся функции при её вызове.
Если в функци нет return - она вернет udefined
Внутри функции не рекоммендуется мутировать внешние объекты
Контекст - область видтмости + переменная this
This - ссылка на объект, который вызывает код в данный момент
Нельзя использовать break/continue справа от оператора „?“

Передаваемые значения копируются в параметры функции и становятся локальными переменными.
Функции имеют доступ к внешним переменным.Но это работает только изнутри наружу.
Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.
Код вне функции не имеет доступа к её локальным переменным.
Функция может возвращать значение. Если этого не происходит, тогда результат равен undefined.
Для того, чтобы сделать код более чистым и понятным, рекомендуется использовать
	локальные переменные и параметры функций, не пользоваться внешними переменными.
Функция, которая получает параметры, работает с ними и затем возвращает результат,
	гораздо понятнее функции, вызываемой без параметров, но изменяющей внешние переменные, что чревато побочными эффектами.

Функции – это объекты. Их свойства:
	name – имя функции. Обычно берётся из объявления функции, но если там нет – JavaScript пытается понять его из контекста.
	length – количество аргументов в объявлении функции. Троеточие («остаточные параметры») не считается.
Функции – это значения. Они могут быть присвоены, скопированы или объявлены в любом месте кода.
Если функция объявлена как отдельная инструкция в основном потоке кода, то это “Function Declaration”.
Если функция была создана как часть выражения, то это “Function Expression”.
Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
Функции, объявленные при помощи Function Expression, создаются только когда поток выполнения достигает их.
В большинстве случаев, когда нам нужно объявить функцию, Function Declaration предпочтительнее,
	т.к функция будет видна до своего объявления в коде.
	Это даёт нам больше гибкости в организации кода, и, как правило, делает его более читабельным.
Исходя из этого, мы должны использовать Function Expression только тогда, когда Function Declaration не подходит для нашей задачи.

? Function Declaration:
Function Declaration может быть вызвана раньше, чем она объявлена.
В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.

function имя(параметры, через, запятую) {
	тело, код функции
}

? Function Expression:
Если функция была создана как часть выражения, то это “Function Expression”.
Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.

let sayHi = function() {
	alert( "Привет" );
};

Если функция объявлена как Function Expression (вне основного потока кода) и имеет имя,
	тогда это называется Named Function Expression (Именованным Функциональным Выражением).
	Это имя может быть использовано для ссылки на себя же, для рекурсивных вызовов и т.п.

? Arrow functions:
let sum = (a, b) => a + b;

Стрелочные функции:
Не имеют this.
Не имеют arguments.
Не имеют super.
Не могут быть вызваны с new.

? Функции-конструкторы
Функции-конструкторы или просто конструкторы, являются обычными функциями,
	но существует общепринятое соглашение именовать их с заглавной буквы.
Функции-конструкторы следует вызывать только с помощью new.
	Такой вызов подразумевает создание пустого this в начале и возврат заполненного в конце.
Мы можем использовать конструкторы для создания множества похожих объектов.

! ====================================================================================================//
! ====================================================================================================//
! ====================================================================================================//

* prototype ==========================================================================================//
В JavaScript все объекты имеют скрытое свойство [[Prototype]],
	которое является либо другим объектом, либо null.
Объект, на который ссылается [[Prototype]], называется «прототипом».
Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj,
	тогда JavaScript попытается найти его в прототипе.

__proto__ — это свойство любого объекта в JS, которое является ссылкой на свойство prototype функции-конструктор

prototype — это собственно свойство функции конструктора, которое хранит в себе интерфейс предка,
	к которому через ссылку __proto__ будет обращаться потомок
у каждой функции в JS есть свойство prototype, но только у функций!
Класс в JS — это синтаксический сахар вокруг функции-конструктора, следовательно, у классов тоже есть свойство prototype.

Потомок связан с родителем свойством __proto__, которое указывает на свойство prototype родителя,
	в котором в свою очередь хранится своя ссылка __proto__, указывающая на его родителя.
	Такая связь называется цепочка прототипов, а сам механизм такого наследования называется прототипное наследование.

Есть только два ограничения для __proto__:
1. Ссылки не могут идти по кругу. JavaScript выдаст ошибку.
2. Значение __proto__ может быть объектом или null. Другие типы игнорируются.

Может быть только один [[Prototype]]. Объект не может наследоваться от двух других объектов.
__proto__ — не то же самое, что внутреннее свойство [[Prototype]]. Это геттер/сеттер для [[Prototype]].
Прототип используется только для чтения свойств.
Операции записи/удаления работают напрямую с объектом.

прототипы никак не влияют на this.
Неважно, где находится метод: в объекте или его прототипе.
this при вызове каждого метода будет соответствовать объекту (перед точкой),
	на котором происходит вызов
Поэтому, когда мы записываем данные в this, они сохраняются в этих объектах.

Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.
Object.keys(..values, ..entries) – игнорируют унаследованные свойства и возвращает только собственные ключи
	Они учитывают только свойства самого объекта, а не его прототипа.

Если унаследованные свойства нам не нужны,
	то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key):
	он возвращает true, если у obj есть собственное (не унаследованное), свойство с именем key.

С точки зрения производительности, для современных движков неважно,
	откуда берётся свойство – из объекта или из прототипа.
Они запоминают, где было найдено свойство, и повторно используют его в следующем запросе.

? F.prototype
Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
Свойство F.prototype (не путать с [[Prototype]]) устанавливает[[Prototype]] для новых объектов при вызове new F().
Значение F.prototype должно быть либо объектом, либо null. Другие значения не будут работать.
Свойство "prototype" является особым, только когда оно назначено функции-конструктору, которая вызывается оператором new.

? Встроенные прототипы
Все встроенные объекты следуют одному шаблону:
Методы хранятся в прототипах (Array.prototype, Object.prototype, Date.prototype и т.д.).
Сами объекты хранят только данные (элементы массивов, свойства объектов, даты).
Примитивы также хранят свои методы в прототипах объектов-обёрток: Number.prototype, String.prototype, Boolean.prototype.
Только у значений undefined и null нет объектов-обёрток.
Встроенные прототипы могут быть изменены или дополнены новыми методами. Но не рекомендуется менять их.
	Единственная допустимая причина – это добавление нового метода из стандарта, который ещё не поддерживается движком JavaScript.

? Методы прототипов
Современные способы установки и прямого доступа к прототипу это:
Object.create(proto[, descriptors])		создаёт пустой объект со свойством [[Prototype]], указанным как proto (может быть null), и необязательными дескрипторами свойств.
Object.getPrototypeOf(obj)						возвращает свойство [[Prototype]] объекта obj (как и геттер __proto__).
Object.setPrototypeOf(obj, proto)			устанавливает свойство [[Prototype]] объекта obj как proto (как и сеттер __proto__).

Ещё методы:
Object.getOwnPropertySymbols(obj)		возвращает массив всех собственных символьных ключей.
Object.getOwnPropertyNames(obj)			возвращает массив всех собственных строковых ключей.
Reflect.ownKeys(obj)								возвращает массив всех собственных ключей.
obj.hasOwnProperty(key)							возвращает true, если у obj есть собственное (не унаследованное) свойство с именем key.

Встроенный геттер/сеттер __proto__ не безопасен, если мы хотим использовать созданные пользователями ключи в объекте.
Как минимум потому, что пользователь может ввести "__proto__" как ключ, от чего может возникнуть ошибка.
Если повезёт – последствия будут лёгкими, но, вообще говоря, они непредсказуемы.
Так что мы можем использовать либо Object.create(null) для создания «простейшего» объекта, либо использовать коллекцию Map.

Object.create даёт лёгкий способ создать поверхностную копию объекта со всеми дескрипторами:
let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));

__proto__ – это геттер/сеттер для свойства [[Prototype]], и находится он в Object.prototype, как и другие методы.

? объекты без свойства __proto__
Мы можем создавать объекты без прототипов с помощью Object.create(null).
	Такие объекты можно использовать как «чистые словари»,
	у них нет проблем с использованием строки "__proto__" в качестве ключа.

* Классы ====================================================================================================//
В JavaScript класс – это разновидность функции.
Методы в классе не разделяются запятой

Свойства записываются с помощью конструктора
При расширении класса к родителю обращаться через super
super нужен всегда, даже если конструктор родителя пустой!

Вот что делает конструкция class User {...}:
	Создаёт функцию с именем User, которая становится результатом объявления класса.
	Код функции берётся из метода constructor (она будет пустой, если такого метода нет).
	Сохраняет все методы в User.prototype.
	При вызове метода объекта new User он будет взят из прототипа.
	Таким образом, объекты new User имеют доступ к методам класса.

Отличия класса от функции-конструктора:
	1. Функция, созданная с помощью class, помечена специальным внутренним свойством
		[[IsClassConstructor]]: true
	2. Методы класса являются неперечислимыми.
		Определение класса устанавливает флаг enumerable в false для всех методов в "prototype".
	3. Классы всегда используют use strict.
		Весь код внутри класса автоматически находится в строгом режиме.

class User { // Создаем класс
	constructor(name, password) { // добавляем свойства с помощью конструктора
		this.name = name;
		this.password = password.toString();
	}
	checkPass() { // добавляем метод
		return this.password.length > 5 ? true : false
	}
}
const person = new User("Jhon", 523556) // создаем новый объект

class Student extends User { // класс Student расширяет User
	constructor(name, password, nickName) { // новый конструктор
		super(name, password); // передать аргументы в родительский класс User
		this.nickName = nickName; // добавить собственные свойства
	}
}
const firstStudent = new Student('ASlex', 7858222, 'AAlexiss') // создаем новый объект

? Статические методы и свойства
Статические методы используются для функциональности, принадлежат классу «в целом»,
	а не относятся к конкретному объекту класса.
В объявлении класса они помечаются ключевым словом static.
Статические свойства используются в тех случаях,когда мы хотели бы сохранить данные 
	на уровне класса, а не какого-то одного объекта.

? instanceof
obj instanceof Class
Оператор вернёт true, если obj принадлежит классу Class или наследующему от него.
Также это работает с функциями-конструкторами и для встроенных классов, таких как Array и Object

? Защищенные данные (get/set)
class User {
	constructor(name) {
	}
	set name(name) {
		this._name = name.trim().toLowerCase()
	}
	get name() {
		return this._name
	}
}

* promise ====================================================================================================//
Промис (Promise) — специальный объект JavaScript, который используется для написания и обработки асинхронного кода.

Интерфейс Promise (промис) представляет собой обёртку для значения, неизвестного на момент создания промиса.
Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными:
	вместо конечного результата асинхронного метода возвращается обещание (дословный перевод слова "промис")
	получить результат в некоторый момент в будущем
Промисы придумали, чтобы организовывать асинхронный код последовательно.

Промис устроен таким образом, что рычаги управления его состоянием остаются у асинхронной функции.
После создания, промис находится в состоянии ожидания pending.
Когда асинхронная операция завершается, функция переводит промис в состояние успеха fulfilled или ошибки rejected.
С помощью методов then(), catch() и finally() мы можем реагировать
	на изменение состояния промиса и использовать результат его выполнения.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
1. state (состояние)
		вначале "pending" (ожидание), потом меняется на:
			"fulfilled" (выполнено успешно) при вызове resolve или на
			"rejected" (выполнено с ошибкой) при вызове reject
2. result (результат)
		вначале undefined,далее изменяется на
			value при вызове resolve(value) или на
			error при вызове reject(error)

Поменять состояние можно только один раз: перейти из pending либо в fulfilled, либо в rejected

Свойства state и result – это внутренние свойства объекта Promise и мы не имеем к ним прямого доступа.
Для обработки результата следует использовать методы .then/.catch/.finally

Промисы имеют несколько недостатков:
	Код не такой лаконичный, как мог быть.
	В цепочке промисов, невозможно выставить брейкпоинт, потому что нет тела функции. Приходится раскрывать функцию.
	Стек ошибок может содержать в себе then.then.then.then....
	Вложенные условия сильно увеличивают количество кода и ухудшают читаемость.
Для решения этих проблем придумали асинхронные функции.

? then, catch, finally =================//
У промиса есть методы then() и catch(), которые позволяют использовать результат работы промиса.

promise.then(
	function(result) {  обработает успешное выполнение },
	function(error) { обработает ошибку }
)

Первый аргумент метода .then – функция, которая выполняется,
	когда промис переходит в состояние «выполнен успешно», и получает результат.
Второй аргумент .then – функция, которая выполняется,
	когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.
Хорошей практикой считается не использовать второй аргумент метода then()
	и обрабатывать ошибки при помощи метода catch().

Если мы заинтересованы только в результате успешного выполнения задачи,
	то в then можно передать только одну функцию
Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента:
	.then(null, errorHandlingFunction).
	Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает то же самое
.catch(f) – это сокращённый, «укороченный» вариант .then(null, f).
В цепочке вызовов catch() обрабатывает ошибки от всех then() между ним и предыдущим catch().

.finally(f)		f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
Идея finally состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.

Отличия от then:
Обработчик, вызываемый из finally, не имеет аргументов.
	В finally мы не знаем, как был завершён промис. Нам это не важно.
Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.
Обработчик finally также не должен ничего возвращать.
	Если это так, то возвращаемое значение молча игнорируется.
	Единственным исключением из этого правила является случай, когда обработчик finally выдает ошибку.
	Затем эта ошибка передается следующему обработчику вместо любого предыдущего результата.

Если промис в состоянии ожидания, обработчики в .then/catch/finally будут ждать его.
Иногда может случиться так, что промис уже выполнен, когда мы добавляем к нему обработчик.
	В таком случае эти обработчики просто запускаются немедленно

response.text()			прочитать полный ответ, возвращает промис
response.json()			читает данные в формате JSON

Обработка промисов всегда асинхронная, т.к. все действия промисов проходят через внутреннюю очередь «promise jobs»,
	так называемую «очередь микрозадач (microtask queue)» (термин v8).
Таким образом, обработчики .then/catch/finally вызываются после выполнения текущего кода.
Если нам нужно гарантировать выполнение какого-то кода после .then/catch/finally,
	то лучше всего добавить его вызов в цепочку .then.

Методы Промисов:
	Promise.all								ждем все промисы, если хоть один с ошибокой - catch, иначе then
	Promise.allSettled				просто ждем выполнения всех промисов (всегда then)
	Promise.race							получаем первый выполнившийся промис (если он был с ошибкой - catch, иначе then)
	Promise.any								получаем первый УСПЕШНО выполнившийся промис
	Promise.resolve(value)		создаёт успешно выполненный промис с результатом value.
	Promise.reject(error)			создаёт промис, завершённый с ошибкой error.
Promise.resolve и Promise.reject редко используются в современном коде,
	так как синтаксис async/await делает их не нужными.

? Примеры
let promiseOne = new Promise((resolve, reject) => {
	resolve('SUCCSESS!!!')
	reject('ERROR!!!')
})

/// Обрабатываем через then
promiseOne.then(
	value => console.log(value),
	error => console.log(error)
)
/// ИЛИ Обрабатываем через catch
promiseOne.catch(
	err => console.log(err)
)
///Обрабатываем finally
promiseOne.finally(() => console.log('finish'))

? async await =================//
async функция всегда возвращает промис.
Значения других типов оборачиваются в завершившийся успешно промис автоматически.

Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится.
После чего оно вернёт его результат, и выполнение кода продолжится.
await работает только внутри async–функций.

Ключевое слово async перед объявлением функции:
	Обязывает её всегда возвращать промис.
	Позволяет использовать await в теле этой функции.

Ключевое слово await перед промисом заставит JavaScript дождаться его выполнения, после чего:
	Если промис завершается с ошибкой, будет сгенерировано исключение, как если бы на этом месте находилось throw.
	Иначе вернётся результат промиса.

? =================//
/// Через then catch
fetch('https://jsonplaceholder.typicode.com/todos')
	.then(response => response.json())
	.then(json => console.log(json))
	.catch(err => console.log(err))

/// Через async await
async function fetchTodos(url) {
	try {
		const response = await fetch(url)
		const json = await response.json()
		console.log(json)
	} catch (err) {
		console.log(err.message)
	}
}
fetchTodos('https://jsonplaceholder.typicode.com/todos')

* API (https://doka.guide/tools/web-app-works/) ========================================================================//
API (Application Programming Interface) — это набор фич, которые одна программа представляет всем остальным.
API может использоваться не только для общения браузера и сервера, но и в принципе для общения разных программ друг с другом.

REST (Representational State Transfer) — стиль общения компонентов, при котором все необходимые данные указываются в параметрах запроса.
REST сейчас — один из самых распространённых стилей API в интернете.
Всё взаимодействие между клиентом и сервером сводится к 4 операциям (CRUD):
	созданию чего-либо, например, объекта пользователя (create, C);
	чтению (read, R);
	обновлению (update, U);
	удалению (delete, D).

SOAP (Simple Object Access Protocol) — формат обмена данными.
Это структурированный формат обмена данными, то есть каждое сообщение следует определённой структуре.
Чаще всего вместе с SOAP используется XML для отражения этой структуры.
SOAP неважно, каким методом передавать сообщения, в отличие от REST.
Структура выглядит так:
	Envelope — корневой элемент, который определяет само сообщение.
	Header содержит атрибуты сообщения, например: информацию о безопасности.
	Body содержит сообщение, которым обмениваются приложения.
	Fault необязательный элемент с ошибками обработки, если они были.

AJAX (Asynchronous JavaScript and XML) — общение между клиентом и сервером без перезагрузки страницы.

MVC (Model-View-Controller) — структура приложения, в которой за данные, их обработку и их вывод отвечают три разных сущности.
Модель (model) отвечает за данные и их структуру.
Представление (view) — за их отображение.
Контроллер (controller) — за их обработку.

JSON — один из самых популярных форматов данных. Он немногословен, понятен и человеку, и компьютеру, много языков с ним уже умеют работать.
В вебе JSON, можно сказать, стандарт, потому что используется как формат по умолчанию во многих фреймворках.

fetch()
На уровне приложения мы используем встроенное браузерное API, а именно — fetch().
Это глобальный метод для отправки запросов.

const response = await fetch('/api/save-text', {
	method: 'POST',
	body: JSON.stringify(State),
})

Поле method — это так называемый HTTP-глагол.
HTTP-методы:
	POST для создания;
	GET для чтения;
	PUT обновляет объект целиком;
	DELETE для удаления.

HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) работает с текстовыми сообщениями,
	которые пересылаются от клиента к серверу (HTTP-запрос) и обратно (HTTP-ответ).
Структура сообщения следующая:
	Стартовая строка (Starting line) говорит нам, запрос или ответ содержит сообщение;
	Заголовки (Headers) описывают тело сообщения, параметры передачи и прочие сведения;
	Тело сообщения (Message Body) содержит данные.
HTTP был разработан как протокол обмена данными между веб-сервером и веб-браузером.
Код состояния в ответе сервера содержит информацию о результате обработки данных.
Существует пять классов кодов состояний:

	1xx — обработка данных на сервере продолжается;
	2xx — успешная обработка данных;
	3xx — перенаправление запросов;
	4xx — ошибка по вине клиента;
	5xx — ошибка по вине сервера.

!  ====================================================================================================//
!  ====================================================================================================//
//* Типы Данных и операторы (https://developer.mozilla.org/ru/docs/Web/JavaScript/Language_overview)===//

JS - Динамически типизируемый язык
	Динамическая типизация: можно менять тип данных у переменной (В статической - нет)

Выражения всегда возвращают значения (присваивание, вычисления и т.д.)
	Конструкции с ? это всегда выражения (if else может быть как инструкцией так и выражением)
Инструкция выполняет определенные действия (объявление переменной, if else, циклы)
	 Инструкция не возвращает значение 

Метод - свойсво объекта, значение которого - функция

В JavaScript есть 8 основных типов данных.
Семь из них называют «примитивными» типами данных:
	number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
	bigint для целых чисел произвольной длины.
	string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
	boolean для true/false.
	null для неизвестных значений – отдельный тип, имеющий одно значение null.
	undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
	symbol для уникальных идентификаторов.
object для более сложных структур данных, не является «примитивным» и стоит особняком

Значения примитивов хранятся непосредственно в переменных (без ссылок!)
В объектах при присваивании переменной значения - переменная не хранит значение, а только ссылку на него
	=> Каждая переменная имеет доступ к объекту и может его поменять для всех
Примитивные типы данных (числа, булевы и строки) хранятся и сравниваются по значению.(Copy by value)
	Можно безопасно менять значение переменной и не бояться, что изменится что-то ещё
Ссылочные типы данных (объекты, массивы) хранятся и сравниваются по ссылке.(Copy by reference)
	При этом при сравнении будет учитываться именно факт того,
	что две переменные ссылаются на один и тот же объект.
	Даже если два объекта содержат идентичные значения это ни на что не повлияет
Изменения внутри объекта будут видны всем у кого есть ссылка на этот объект.
	Прямое изменение данных объекта называется мутирование.
	Лучше стараться избегать мутации объекта, т.к это может приводить к неочевидным ошибкам
Чтобы безопасно менять ссылочный тип данных его необходимо предварительно скопировать.
	Таким образом будет создана другая ссылка и любые изменения не затронут старый объект
	1. const person2 = Object.assign({}, person) - Вложенные объекты не копируются
	2. const person2 = {... person} - Вложенные объекты не копируются
	3. const person2 = JSON.parse(JSON.stringify(person))
	4. const person2 = structuredClone(person)

typeof показывает тип данных. Имеет две формы: typeof x или typeof(x).
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.

? null и undefined
Специальное значение null не относится ни к одному из типов, описанных выше.
Оно формирует отдельный тип, который содержит только значение null
В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.
Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

undefined формирует тип из самого себя так же, как и null.
Оно означает, что «значение не было присвоено».
Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined

Технически можем присвоить значение undefined любой переменной
Но так делать не рекомендуется. Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения,
а undefined – для проверок, была ли переменная назначена.

null и undefined равны друг другу и не равны никаким другим значениям. Это специальное правило языка.
У null и undefined нет соответствующих «объектов-обёрток», и они не имеют никаких методов.

При использовании математических операторов и других операторов сравнения < > <= >=
Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.

? Преобразование типов
Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.

Строковое String(value)		Происходит, когда нам нужно что-то вывести.
Численное Number(value)		Происходит в математических операциях.

Преобразование подчиняется правилам:
	undefined	NaN
	null	0
	true / false	1 / 0
	string	Пробельные символы по краям обрезаются.
	Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число.
	При ошибке результат NaN.

Логическое Boolean(value)		Происходит в логических операциях.
Подчиняется правилам:
	0, null, undefined, NaN, "" - false
	любое другое значение - true

undefined при численном преобразовании становится NaN, не 0.
"0" и строки из одних пробелов типа " " при логическом преобразовании всегда true.

? var
Существует 2 основных отличия var от let/const:
	Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.
	Инициализация переменных var производится в начале исполнения функции (или скрипта для глобальных переменных).

? Операторы сравнения
Операторы сравнения возвращают значения логического типа.
Строки сравниваются посимвольно в лексикографическом порядке.
Значения разных типов при сравнении приводятся к числу. Исключением является сравнение с помощью операторов строгого равенства/неравенства.
Значения null и undefined равны == друг другу и не равны любому другому значению.
Будьте осторожны при использовании операторов сравнений вроде > и < с переменными, которые могут принимать значения null/undefined. Хорошей идеей будет сделать отдельную проверку на null/undefined.

оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.
оператор ?? Используют когда значение 0 надо расценивать как true
Запрещено использовать ?? вместе с || или && без явно указанного приоритета, то есть без скобок.
Важное различие между ними заключается в том, что:
|| возвращает первое истинное значение.
'??' возвращает первое определённое значение.

? Синтаксис опциональной цепочки ?. имеет три формы:
obj?.prop – возвращает obj.prop если obj существует, в противном случае undefined.
obj?.[prop] – возвращает obj[prop] если obj существует, в противном случае undefined.
obj.method?.() – вызывает obj.method(), если obj.method существует, в противном случае возвращает undefined.
'?.' проверяет левую часть на null/undefined и позволяет продолжить вычисление, если это не так.
Цепочка ?. позволяет безопасно получать доступ к вложенным свойствам
Опциональная цепочка работает только с объявленными переменными.

? Перебираемые объекты
Объекты, которые можно использовать в цикле for..of, называются итерируемыми.
Технически итерируемые объекты должны иметь метод Symbol.iterator.
Результат вызова obj[Symbol.iterator] называется итератором. Он управляет процессом итерации.
Итератор должен иметь метод next(), который возвращает объект {done: Boolean, value: any},
	где done:true сигнализирует об окончании процесса итерации, в противном случае value – следующее значение.
Метод Symbol.iterator автоматически вызывается циклом for..of, но можно вызвать его и напрямую.
Встроенные итерируемые объекты, такие как строки или массивы, также реализуют метод Symbol.iterator.
Строковый итератор знает про суррогатные пары.

Объекты, имеющие индексированные свойства и length, называются псевдомассивами.
Они также могут иметь другие свойства и методы, но у них нет встроенных методов массивов.
Большинство встроенных методов рассчитывают на то,что они будут работать с итерируемыми объектами или псевдомассивами
	вместо «настоящих» массивов,потому что эти объекты более абстрактны.

* this (https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this) ====================//
В большинстве случаев значение this определяется тем, каким образом вызвана функция.
Значение this не может быть установлено путём присваивания во время исполнения кода
	и может иметь разное значение при каждом вызове функции.
bind() используется для привязки значения ключевого слова this независимо от того, как вызвана функция.

В глобальном контексте выполнения (за пределами каких-либо функций) this ссылается на глобальный объект
	вне зависимости от режима (строгий или нестрогий).
В пределах функции значение this зависит от того, каким образом вызвана функция.

Если код не в строгом режиме, и значение this не устанавливается вызовом,
	по умолчанию будет использоваться объект global, которым в браузере является window.
В строгом режиме, если значение this не установлено в контексте выполнения,
	оно остаётся undefined
	Для того, чтобы при вызове функции установить this в определённое значение, используйте call() или apply(),
Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this
	принимает значение объекта, по отношению к которому вызван метод.
	(Имеет значение только контекст вызова, а не контекст создания)

Если метод находится в цепочке прототипов, то this ссылается на объект, на котором был вызван метод,
	т.е. так, словно метод является методом самого объекта, а не прототипа.

? Непрямой вызов (call, apply, bind)
Оба первым аргументом принимают this. То есть они позволяют настроить контекст снаружи, к тому же — явно.
Разница между call() и apply() — в том, как они принимают аргументы для самой функции после this.
	call() принимает аргументы списком через запятую,
	apply() же — принимает массив аргументов.
В остальном они идентичны

bind() метод, который позволяет связывать контекст выполнения с функцией,
	чтобы «заранее и точно» определить, какое именно значение будет у this.
bind(), в отличие от call() и apply(), не вызывает функцию сразу.
Вместо этого он возвращает другую функцию — связанную с указанным контекстом навсегда.
Контекст у этой функции изменить невозможно

* Map & Set (https://learn.javascript.ru/map-set) ==============================================================//
? Map – коллекция пар ключ-значение.
Отличия от обычного объекта Object:
	Что угодно может быть ключом, в том числе и объекты.
	Есть дополнительные методы, свойство size.

Методы и свойства:
	new Map([iterable]) – создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар [ключ,значение] для инициализации.
	map.set(key, value) – записывает по ключу key значение value.
	map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
	map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
	map.delete(key) – удаляет элемент по ключу key.
	map.clear() – очищает коллекцию от всех элементов.
	map.size – возвращает текущее количество элементов.

Обычный объект Object приводит ключи к строкам
Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения: 1, '1'

Для перебора коллекции Map есть 3 метода:
	map.keys()			возвращает итерируемый объект по ключам,
	map.values()		возвращает итерируемый объект по значениям,
	map.entries()		возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.
В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов.

Создать Map из обычного объекта:
	let map = new Map(Object.entries(obj))
Создать обычный объект из Map:
	let obj = Object.fromEntries(map)

? Set – коллекция уникальных значений, так называемое «множество».
Объект Set – это особый вид коллекции: «множество» значений (без ключей),
	где каждое значение может появляться только один раз.

Методы и свойства:
	new Set(iterable) – создаёт Set, можно указать перебираемый объект со значениями для инициализации.
	set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
	set.delete(value) – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.
	set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
	set.clear() – удаляет все имеющиеся значения.
	set.size – возвращает количество элементов в множестве.

Set имеет те же встроенные методы, что и Map:
	set.values()		возвращает перебираемый объект для значений,
	set.keys()			то же самое, что и set.values(), присутствует для обратной совместимости с Map,
	set.entries()		возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.

Перебрать set можно с помощью for..of или forEach
Перебор Map и Set всегда осуществляется в порядке добавления элементов,
	так что нельзя сказать, что это – неупорядоченные коллекции,
	но поменять порядок элементов или получить элемент напрямую по его номеру нельзя.

? WeakMap – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты,
	и автоматически удаляющая их вместе с соответствующими значениями,
	как только они становятся недостижимыми иными путями.

?WeakSet – это Set-подобная коллекция, которая хранит только объекты и удаляет их,
	как только они становятся недостижимыми иными путями.

Обе этих структуры данных не поддерживают методы и свойства,
	работающие со всем содержимым сразу или возвращающие информацию о размере коллекции.
	Возможны только операции на отдельном элементе коллекции.
WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта.
Если объект удаляется из основного хранилища и нигде не используется,
	кроме как в качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически.

* Ассоциативный массив (https://itchief.ru/javascript/associative-arrays) ================================//
Ассоциативный массив – это массив, в котором обращение к значению осуществляется по ключу.
При этом в качестве ключа используется не порядковый номер (индекс),
	а некоторая строка, которую мы устанавливаем сами.
Таким образом представить ассоциативный массив можно как набор пар «ключ-значение».
	При этом каждое значение связано с определённым ключом.

Создание ассоциативных массивов в JavaScript можно выполнить двумя разными способами:
	1. С помощью объекта Map (см. Map);
	2, Посредством объектов.

Перебор ассоциативного массива (объекта Map) обычно осуществляется с помощью цикла for...of.
При этом итерацию можно организовать по ключам, значениям и записям ([key, values]).

В качестве ассоциативного массива можно использовать обычный объект.
Создание пустого ассоциативного массива через объект:

	const myArray = {
		'key1': 'value1',
		'key2': 'value2',
		...
	}

Добавление нового элемента (пары «ключ-значение»):
arr['key1'] = 'текстовое значение'
arr.key2 = 22;
Добавление нового элемента будет выполняться только в том случае, если данного ключа в нём нет. 
Если данный ключ уже существует, то указанное значение просто изменит существующее.
В качестве значения можно использовать не только примитивные типы данных, но и ссылочные.

Получить количество ключей (длину) можно так:
Используем keys, чтобы получить массив ключей. А затем с помощью length их длину
Object.keys(myArray).length

Перебор ключей с помощью цикла for...in:

	for(key in myArray) {
		console.log( `${key} = ${myArray[key]}` );
	}

!  ====================================================================================================//
!  ====================================================================================================//
!  ====================================================================================================//

* Date ================================================================================================//
Date — класс для работы со временем. В основном используется для отображения и вычисления.(https://doka.guide/js/date/)
Время отображается в двух форматах:
	UTC — время по Гринвичу;
	В текущей часовой зоне (например, UTC+3 для Москвы).

? Создать новый экземпляр класса можно несколькими способами:
new Date() создаёт экземпляр Date с текущей датой и временем.
new Date(значение) создаёт Date с переданным значением времени.
Значение должно быть в формате, который распознается методом Date.parse(), то есть быть совместимым с IETF RFC 2822 или с ISO8601.
			
new Date(год, месяц, день, часы, минуты, секунды, миллисекунды) создаёт класс Date в местной часовой зоне. // new Date(2002, 1, 6, 15, 45)
	Год и месяц являются обязательными параметрами. Остальные параметры, начиная с часов, будут по умолчанию равны 0, а день — 1.
	При установке месяца, отсчёт идёт с 0, где 0 — это январь.
	При выводе дня недели возвращаемое значение также начинается с 0 и означает воскресенье.
	Исключением из этого правила являются параметры, связанные с годом и днём месяца (первое число месяца — 1).

В формате ISO:
new Date('YYYY-MM-DDTHH:mm:ss.sssZ') // new Date('2002-02-06T15:45')
	Здесь месяц начинается с 1. T - разделитель. Z - нулевое смещение (не учитывался часовой пояс)
new Date('ISO')			преобразует в стандартный формат

Unix - формат (таймстамп):
new Date(миллисекунды) создаёт Date со временем в миллисекундах(Unix - формат).
	Количество миллисекунд измеряется с 1 января 1970 года UTC (таймстамп).
Date.now() — метод, который возвращает текущее время в миллисекундах, прошедших с 1 января 1970 года UTC.
	Метод очень похож на new Date(), но, так как нет ключевого слова new, экземпляр класса не создаётся
	Возвращается только число: console.log(Date.now()) // 1661370397669
	Принимает значение в секундах. JS работает в милисекундах, поэтому *1000
	Используется для точного сравнения времени
getTime('дата и время')		преобразует в Unix формат
new Date(timestamp)				преобразует в стандартный формат

Есть два метода, которые не привязаны к часовой зоне:
	getTime() возвращает значение в миллисекундах, прошедших с 1 января 1970 года, соответствующее указанной дате по UTC.
	getTimezoneOffset() возвращает смещение в минутах между текущей часовой зоной и UTC.

? Математические операции необходимо выполнять со временем в формате UTC.
Обычные операции не учитывают летнее время часовых зон, поэтому результаты могут быть некорректны.

date.toISOString()						переконверт. в ISO формат
date.toDateString()						переконверт. более читаемый формат
date.toLocaleDateString('en')	переконверт. дату более читаемый формат с учетом языка страны
date.toLocaleTimeString('en')	переконверт. время более читаемый формат с учетом языка страны
date.toLocaleString('en')			переконверт. дату и время более читаемый формат с учетом языка страны

? Получить время и дату
 getFullYear()								возвращает год;
 getMonth()										возвращает месяц с 0 до 11;
 getDate()										возвращает день месяца с 1 до 31;
 getDay()											возвращает порядковый номер дня недели с 0(вс) до 6(сб)
 getHours()										возвращает часы с 0 до 23;
 getMinutes()									возвращает минуты от 0 до 59;
 getSeconds()									возвращает секунды от 0 до 59;
 getMilliseconds()						возвращает миллисекунды от 0 до 999.

Все вышеперечисленные методы возвращают значения для текущей часовой зоны.
Если необходимо вернуть время по Гринвичу, то нужно в метод добавить UTC:
	getUTCFullYear(), getUTCMonth(), getUTCDate(), getUTCDay(), getUTCHours(),
	getUTCMinutes(),getUTCSeconds(), getUTCMilliseconds()

? Установка значений
Также, как и с получением значений, у многих методов есть присваивание значений в локальной часовой зоне и UTC.
Для локальной:

setFullYear(год, месяц, день)						устанавливает год, значения месяца и дня необязательны.
setMonth(месяц, день)										устанавливает месяц, передавать день необязательно.
setDate(день)														устанавливает день месяца.
setHours(часы, минуты, сек, миллисек)		устанавливает часы. Значения минут, секунд, миллисекунд необязательны.
setMinutes(минуты, сек, миллисек) 			устанавливает минуты. Секунды и миллисекунды необязательны.
setSeconds(сек, миллисек)								устанавливает секунды. Миллисекунды передавать необязательно.
setMilliseconds(миллисек) 							устанавливает миллисекунды.

Для UTC аналогичные методы, только добавляем UTC после set. Например, setUTCMilliseconds(миллисекунды).
И метод, который относится только к UTC:
setTime(значение) устанавливает значение, которое равно количеству миллисекунд, прошедших с 1 января 1970 года.

* Console ====================================================================================================//
console.dir()			Позволит посмотреть дочерние объекты и их свойства.
console.warn()		Выводит предупреждающее сообщение.
console.error()		Выводит сообщение об ошибке.
console.assert()	Выводит в консоль сообщение и стек вызова метода, если первый аргумент false.
console.table()		Отображает табличные данные в виде таблицы.
console.group()		Создаёт новую группировку сообщений. Для завершения группы вызовите groupEnd().
console.time()		Запускает таймер с именем из переданного параметра. Для завершения console.timeEnd()
console.clear()   Очистить консоль

console.log и console.dir. Для JavaScript-объектов эти команды обычно выводят одно и то же.
Но для DOM-элементов они работают по-разному:
	console.log(elem) выводит элемент в виде DOM-дерева.
	console.dir(elem) выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.

//* Планирование: setTimeout и setInterval =========================================//
setTimeout() позволяет исполнить функцию через указанный промежуток времени.
setInterval() позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
	Функции возвращают числовой идентификатор установленного таймера.
	Этот идентификатор можно передать в функцию clearTimeout()/clearInterval(), чтобы остановить таймер.

setTimeout()/setInterval() принимает два аргумента:
	функция, которая выполнится, когда таймер закончится;
	время таймера в миллисекундах.

clearTimeout/clearInterval - останавливают setTimeout/setTimeout. В качестве аргумента - id таймера

Создание таймеров происходит синхронно
Функция внутри таймера выполняется асинхронно

Вложенный вызов setTimeout является более гибкой альтернативой setInterval.
Также он позволяет более точно задать интервал между выполнениями.

* Деструктуризация =======================================================================================//
Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.
	? В объектах выжены названия ключей
const { user_name, user_age } = { user_name: 'Alex', user_age: 19 }
	? Переименование ключей объектов
const { user_name: userName, user_age: userAge } = { user_name: 'Alex', user_age: 19 }
	? Переименование + значения по умолчанию
const { user_name: userName = 'unknown' } = { user_name: 'Alex', user_age: 19 }
	? В массивах важен порядок
const [one, two, three, four] = [1, 2, 3, 4]
	? Значания по умолчанию (без него - undefined)
const [userName = 'User', userAge = 18, hasCar = false] = [, ,]

* Остаточные параметры и оператор расширения============================================================//
"..." в коде, могут быть как остаточные параметры, так и оператор расширения.
Как отличить их друг от друга:
Если ... располагается в конце списка параметров функции, то это «остаточные параметры».
	Он собирает остальные неуказанные аргументы и делает из них массив.
Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения».
	Он извлекает элементы из массива.

Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.
С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.
Вместе эти конструкции помогают легко преобразовывать наборы значений в массивы и обратно.

К аргументам функции можно обращаться и по-старому — через псевдомассив arguments.

* try catch ====================================================================================================//
try {
	 исполняем код
} catch(err) {
	 если случилась ошибка, прыгаем сюда
	 err - это объект ошибки
} finally {
	 выполняется всегда после try/catch
}

Работает она так:
Сначала выполняется код внутри блока try {...}.
Если в нём нет ошибок, то блок catch(err) игнорируется:
	выполнение доходит до конца try и потом далее, полностью пропуская catch.
Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления переходит в начало catch(err).
Переменная err (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.

try..catch может обрабатывать только ошибки, которые возникают в корректном коде.
	JavaScript-движок сначала читает код, а затем исполняет его.
	Ошибки, которые возникают во время фазы чтения, называются ошибками парсинга.
	Их нельзя обработать (изнутри этого кода), потому что движок не понимает код.
	Такие ошибки называют «ошибками во время выполнения», а иногда «исключениями».

try..catch работает синхронно
Чтобы поймать исключение внутри запланированной функции, try..catch должен находиться внутри самой этой функции

Секций catch или finally может не быть,
	то есть более короткие конструкции try..catch и try..finally также корректны.
Блок finally срабатывает при любом выходе из try..catch, в том числе и return.

Если объект ошибки не нужен, мы можем пропустить его, используя catch вместо catch(err).

Объекты ошибок содержат следующие свойства:
	message – понятное человеку сообщение.
	name – строка с именем ошибки (имя конструктора ошибки).
	stack (нестандартное, но хорошо поддерживается) – стек на момент ошибки.

Оператор throw генерирует ошибку.
	Синтаксис: throw <объект ошибки>
Аргументом throw может быть что угодно, но обычно это объект ошибки, наследуемый от встроенного класса Error.

Проброс исключения – это очень важный приём обработки ошибок:
	блок catch обычно ожидает и знает, как обработать определённый тип ошибок,
	поэтому он должен пробрасывать дальше ошибки, о которых он не знает.

Есть простое правило:
Блок catch должен обрабатывать только те ошибки, которые ему известны, и «пробрасывать» все остальные.
Техника «проброс исключения» выглядит так:
	Блок catch получает все ошибки.
	В блоке catch(err) {...} мы анализируем объект ошибки err.
	Если мы не знаем как её обработать, тогда делаем throw err.

В конструкцию try...catch можно добавить блок finally, который выполнится после блоков try и catch.
	Неважно какой код выполнился в предыдущих блоках, после их завершения
	(даже если из catch была выброшена новая ошибка) исполнится код в блоке finally.
Наличие блока finally необязательно. finally можно использовать и без блока catch.

Конструкция try...catch работает только синхронно.
Таким образом, с помощью try...catch нельзя обработать ошибку, которая возникла в асинхронном коде.
Чтобы поймать ошибку из setTimeout(), блоки try...catch должны находиться внутри функции.

Переменные внутри try..catch..finally локальны

//* import/export ====================================================================================================//
? Именованные экспорты
Внутри модулей всегда используется строгий режим (use strict)
При использовании ключевого слова export рядом с функцией или переменной,
	мы экспортируем конкретную функцию или переменную.
У таких переменных и функций обязательно должно быть имя,
	потому что именно по этому имени мы будем получать доступ к ним из других модулей.
Поэтому такие экспорты называются именованными.
У экспортируемой функциональности есть имя и по этому же имени мы будем импортировать её в других модулях.

export
	export const a = 5
export нескольких
	export {a, b, c}

	import
import { a } from "./test";
	import нескольких
import { a, b ,c } from "./test";

Переименование
	import { a as b } from "./test";
Переименование нескольких
	import { a as b, f as t } from "./test";

? Экспорты по умолчанию.
Когда мы из модуля экспортируем какую-то функциональность по умолчанию, мы можем опустить имя,
	но обязаны использовать ключевое слово default после export
Рекомендуем использовать именованные экспорты вместо экспортов по умолчанию там, где это возможно.

export default MyComponent
import MyComponent from "./MyComponent";


//* Области видимости ====================================================================================================//
	https://metanit.com/web/javascript/3.2.php
	https://college.arthur-nesterenko.dev/javascript/hoisting
Существуют два типа областей видимости: глобальная и локальная.
Если переменная объявлена вне всех функций или фигурных скобок ({}), 
	то считается, что она определена в глобальной области видимости.
Переменные, которые используются только в определенной части кода,
	считаются помещенными в локальную область видимости. Такие переменные называются локальными.

В JavaScript выделяют два типа локальных областей видимости:
	1. область видимости функции
	2. область видимости блока

Область видимости функции
	Переменная, объявленная внутри функции, доступна только внутри функции.
	Код снаружи функции не имеет к ней доступа.
	При этом не зависит от того, что это за переменная - var или let, либо const
Область видимости блока
	Переменная, объявленная внутри фигурных скобок {} через const или let, доступна только внутри фигурных скобок.
	Переменная, объявленная с помощью var, может использоваться вне блока.
Блочная область видимости является частным случаем области видимости функции,
	т.к. функции объявляются с фигурными скобками

С помощью var можно использовать значение до того, как оно будет присвоено, и оно вернет undefined.
Если сделать, то же самое с let - будет ReferenceError.

Подъем функции в области видимости
Функции, объявленные как «function declaration», всегда поднимаются наверх в текущей области видимости.
Если же функция объявляется как «function expression», то такая функция не поднимается в текущей области видимости.

Функции не имеют доступа к областям видимости других функций,когда они объявляются раздельно,
	даже если одна функция используется в другой.
Когда функция объявляется в другой функции, то внутренняя функция имеет доступ к переменным внешней функции.
	В тоже время внешняя функция не имеет доступа к переменным внутренней функции.

//* Замыкания  ====================================================================================================//
	https://habr.com/ru/articles/338462/

Всякий раз, когда вы вызываете функцию внутри другой функции, вы создаете замыкание. 
Говорят, что внутренняя функция является замыканием. Результатом замыкания обычно является то, 
	что в дальнейшем становятся доступными переменные внешней функции.

Благодаря замыканиям появляется доступ к внешней функции, поэтому они обычно используются для двух целей:
	контроля побочных эффектов
	создания приватных переменных


//!  ====================================================================================================//






*/