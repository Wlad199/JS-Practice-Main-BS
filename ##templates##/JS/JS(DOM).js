/*
! DOM ====================================================================================================//

? Получить Узел =================//
<html> = document.documentElement
<head> = document.head
<body> = document.body

Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.
Есть два основных набора ссылок:
	1. Для всех узлов:
	parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
	Проверить наличие узла: hasChildNodes (element.hasChildNodes())
	2. Только для узлов-элементов:
	parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.

childNodes похож на массив, на самом деле это не массив,
	а коллекция – особый перебираемый объект-псевдомассив. Коллекции живые.
И есть два важных следствия из этого:
	1. Для перебора коллекции мы можем использовать for..of
	2. Методы массивов не будут работать, потому что коллекция – это не массив
		Если нам хочется использовать именно методы массива,
		то мы можем создать настоящий массив из коллекции, используя Array.from:
			Array.from(document.body.childNodes) // сделали массив

В DOM значение null значит «не существует» или «нет такого узла».
Не используйте цикл for..in для перебора коллекций!!!

parentElement возвращает родитель-элемент, а parentNode возвращает «любого родителя».
Обычно эти свойства одинаковы: они оба получают родителя.
За исключением document.documentElement:
	document.documentElement.parentNode; // выведет document
	document.documentElement.parentElement; // выведет null

? Поиск =================//
Есть 6 основных методов поиска элементов в DOM:
Метод											Ищет по...		Ищет внутри элемента?	Возвращает живую коллекцию?
querySelector							CSS-selector						✔												-
querySelectorAll					CSS-selector						✔												-
getElementById								id									-												-
getElementsByName						name									-												✔
getElementsByTagName			tag or '*'							✔												✔
getElementsByClassName			class									✔												✔

Безусловно, наиболее часто используемыми являются методы querySelector и querySelectorAll,
	но и методы getElement(s)By* могут быть полезны в отдельных случаях, а также встречаются в старом коде.
Метод getElementById можно вызвать только для объекта document.
	Он осуществляет поиск по id по всему документу.

Все методы "getElementsBy*" возвращают живую коллекцию.
	Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.
querySelectorAll возвращает статическую коллекцию. Это похоже на фиксированный массив элементов.

Псевдоклассы в CSS-селекторе, в частности :hover и :active, также поддерживаются.
Например, document.querySelectorAll(':hover') вернёт коллекцию
	(в порядке вложенности: от внешнего к внутреннему) из текущих элементов под курсором мыши.

elem.matches(css)				проверяет, удовлетворяет ли элемент CSS-селектору.Возвращает true или false
elem.closest(css)				ищет ближайшего по иерархии предка, соответствующему данному CSS-селектору.
												Возвращает либо предка, либо null Сам элемент также включён в поиск.
elemA.contains(elemB)		вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB.

? Получить содержимое =================//
DOM-узлы – это обычные JavaScript объекты.
Для наследования они используют классы, основанные на прототипах.

nodeType - «старомодный» способ узнать «тип» DOM-узла.
Его значением является цифра:
	elem.nodeType == 1 для узлов-элементов,
	elem.nodeType == 3 для текстовых узлов,
	elem.nodeType == 9 для объектов документа,
В современных скриптах, чтобы узнать тип узла, мы можем использовать метод instanceof

elem.nodeName / elem.tagName		узнать имя его тега из свойств
tagName есть только у узлов-элементов, а nodeName может что-то сказать о других типах узлов.
Если мы имеем дело только с элементами, то можно использовать tagName или nodeName, нет разницы.
Имена тегов (кроме XHTML) всегда пишутся в верхнем регистре

innerHTML				Внутреннее HTML-содержимое узла-элемента в виде строки. Можно изменять.
outerHTML				Полный HTML узла-элемента. Как innerHTML плюс сам элемент.
								Запись в elem.outerHTML не меняет elem. Вместо этого она заменяет его во внешнем контексте.
textContent			Текст внутри элемента: HTML за вычетом всех <тегов>.
								Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст.
								Можно использовать для защиты от вставки произвольного HTML кода.
innerText				Позволяет считывать или задавать текстовое содержимое элемента.
								Не будет считываться содержимое скрытых с помощью CSS элементов, а также содержимое тегов <script> и <style>
hidden 					Когда true, делает то же самое, что и CSS display:none. (elem.hidden = true)

Свойство innerHTML есть только у узлов-элементов.
У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и data

У DOM-элементов есть дополнительные свойства, зависящие от класса:
value						значение для <input>, <select> и <textarea> (HTMLInputElement, HTMLSelectElement…).
href						адрес ссылки «href» для <a href="..."> (HTMLAnchorElement).
id							значение атрибута «id» для всех элементов (HTMLElement).

? Методы для создания узлов =================//
document.createElement("tag")			создаёт элемент с заданным тегом,
document.createTextNode(value)		создаёт текстовый узел (редко используется)
elem.cloneNode(deep)							клонирует элемент, если deep==true, то со всеми дочерними элементами

Вставка и удаление (nodes or strings):
node.before					вставляет прямо перед node
node.prepend				вставляет в node в начало
node.append					вставляет в node в конец
node.after					вставляет сразу после node
node.replaceWith		заменяет node
node.remove()				удаляет node

elem.insertAdjacentHTML(where, html) вставляет HTML в зависимости от where:
"beforebegin"				вставляет html прямо перед elem
"afterbegin"				вставляет html в elem в начало
"beforeend"					вставляет html в elem в конец
"afterend"					вставляет html сразу после elem

elem.insertAdjacentText				строка text вставляется «как текст», вместо HTML
elem.insertAdjacentElement		вставляет элемент elem
insertAdjacentText & insertAdjacentElement используются редко

Если нам нужно переместить элемент в другое место – нет необходимости удалять его со старого.
Все методы вставки автоматически удаляют узлы со старых мест.
	second.after(first); // берёт #second и после него вставляет #first

? Css =================//
Для управления классами существуют два DOM-свойства:
elem.className		строковое значение, удобно для управления всем набором классов
elem.classList		(add/remove/toggle/contains) для управления отдельными классами
	classList является перебираемым, можно перечислить все классы при помощи for..of

Чтобы изменить стили(style & style.cssText):
Свойство style является объектом со стилями в формате camelCase
	Чтение и запись в него работают так же, как изменение соответствующих свойств в атрибуте "style"
	Свойство style оперирует только значением атрибута "style", без учёта CSS-каскада.
	Поэтому, используя elem.style, мы не можем прочитать ничего, что приходит из классов CSS.
		background-color: 'red'	=> elem.style.backgroundColor = 'red'
		display: "none"					=> elem.style.display = "none"
		вернуть обратно					=> elem.style.display = ""

Свойство style.cssText соответствует всему атрибуту "style", полной строке стилей.
	elem.cssText перезависывает все css свойства
	добавление новых стилей к существующим стилям elem, используем +=
	elem.style.cssText += `
		top: ${top};
		left: ${left};
	`;

Для чтения окончательных стилей (Только для чтения)
	getComputedStyle(elem, [pseudo])
	Для правильного получения значения нужно указать точное свойство.
	Например: paddingLeft, marginTop, borderTopWidth.

? Атрибуты =================//
Когда браузер загружает страницу, он парсит HTML и генерирует из него DOM-объекты.
Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов.
DOM-свойства и методы ведут себя так же, как и обычные объекты JavaScript:
	Им можно присвоить любое значение.
	Они регистрозависимы (нужно писать elem.nodeType, не elem.NoDeTyPe).

hasAttribute('name')					Проверить наличие Атрибута
getAttribute('name')					Получить значение Атрибута
setAttribute('name', 'value')	Установить значение Атрибута
removeAttribute('name')				Удалить Атрибут
elem.attributes								Получить коллекцию всех атрибутов

Все атрибуты, в том числе те, которые мы установили, видны в outerHTML.
Коллекция attributes является перебираемой (for of).
В ней есть все атрибуты элемента в виде объектов со свойствами name и value.

У HTML-атрибутов есть следующие особенности:
	Их имена регистронезависимы (id то же самое, что и ID).
	Их значения всегда являются строками.

Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами.
Они доступны в свойстве dataset.
Например, если у elem есть атрибут "data-about", то обратиться к нему можно как elem.dataset.about.
Например, data-order-state становятся: dataset.orderState.

//* Размеры и прокрутка окна ================================================================================//

? Размеры
document.documentElement.clientWidth		Ширина видимой части документа (без полосы прокрутки)
document.documentElement.clientHeight		Высота видимой части документа (без полосы прокрутки)
window.innerWidth											Ширина документа (с полосой прокрутки)
window.innerHeight										Высота документа (с полосой прокрутки)

Ширина/высота всего документа со всей прокручиваемой областью страницы:
let scrollHeight = Math.max(
	document.body.scrollHeight, document.documentElement.scrollHeight,
	document.body.offsetHeight, document.documentElement.offsetHeight,
	document.body.clientHeight, document.documentElement.clientHeight
);

? Прокрутка
window.pageYOffset							получить прокрутку окна сверху (только для чтения)
window.pageXOffset							получить прокрутку окна слева (только для чтения)

Изменить текущую прокрутку:
window.scrollTo(pageX,pageY)		абсолютные координаты
window.scrollBy(x,y)						прокрутка относительно текущего места
elem.scrollIntoView(top)				прокрутить страницу так, чтобы сделать elem видимым (выровнять относительно верхней/нижней части окна).
	top или true - прокрутка к верхей части (по умолчанию)
	false - прокрутка к нижней части

? Метрики
offsetParent										ближайший CSS-позиционированный родитель или ближайший td, th, table, body.
offsetLeft/offsetTop						позиция в пикселях верхнего левого угла относительно offsetParent.
offsetWidth/offsetHeight				«внешняя» ширина/высота элемента, включая рамки.
clientLeft/clientTo							расстояние от верхнего левого внешнего угла до внутренного.
	Для операционных систем с ориентацией слева-направо эти свойства равны ширинам левой/верхней рамки.
	Если язык ОС таков, что ориентация справа налево, так что вертикальная полоса прокрутки находится не справа, а слева, то clientLeft включает в своё значение её ширину.
clientWidth/clientHeight				ширина/высота содержимого вместе с внутренними отступами padding, но без полосы прокрутки.
scrollWidth/scrollHeight				ширины/высота содержимого, аналогично clientWidth/Height, но учитывают прокрученную, невидимую область элемента.
scrollLeft/scrollTop						ширина/высота прокрученной сверху части элемента, считается от верхнего левого угла.
Все свойства доступны только для чтения, кроме scrollLeft/scrollTop, изменение которых заставляет браузер прокручивать элемент.

Любая точка на странице имеет координаты:
elem.getBoundingClientRect()		координаты относительно окна браузера
elem.getBoundingClientRect()		относительно документа плюс текущая прокрутка страницы.
Координаты в контексте окна подходят для использования с position:fixed,
	а координаты относительно документа – для использования с position:absolute.

 todo ====================================================================================================//
 todo ====================================================================================================//

! Браузерные события =====================================================================================//

Есть три способа назначения обработчиков событий:
1. Атрибут HTML: onclick="...".
2. DOM-свойство: elem.onclick = function.
	Убрать обработчик можно назначением elem.onclick = null.

3. Специальные методы:
elem.addEventListener(event, handler, [options])			для добавления
elem.removeEventListener(event, handler, [options])		для удаления
	Для удаления нужно передать именно ту функцию-обработчик которая была назначена.
event - Имя события, например "click".
handler - Ссылка на функцию-обработчик.
options - Дополнительный объект со свойствами:
	once: если true, тогда обработчик будет автоматически удалён после выполнения.
	capture: фаза, на которой должен сработать обработчик. options может быть false/true, это то же самое, что {capture: false/true}.
	passive: если true, то указывает, что обработчик никогда не вызовет preventDefault()

	element.addEventListener('click', addClass, { 'once': true }) // Выполнится только 1 раз

? DOMContentLoaded
DOMContentLoaded - событие, которое срабатывает когда завершена загрузка и построение DOM документа:
document.addEventListener("DOMContentLoaded", function() {
	alert("DOM построен"); // а вот так сработает
});

? handleEvent
Можно назначить обработчиком не только функцию, но и объект при помощи addEventListener.
В этом случае, когда происходит событие, вызывается метод объекта handleEvent.
addEventListener получает объект в качестве обработчика,
	он вызывает object.handleEvent(event), когда происходит событие:

elem.addEventListener('click', {
		handleEvent(event) {
			alert(event.type + " на " + event.currentTarget);
		}
});

? События мыши:
click											происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
contextmenu								происходит, когда кликнули на элемент правой кнопкой мыши.
mousedown / mouseup				когда нажали / отжали кнопку мыши на элементе.
mousemove									при движении мыши.
mouseover / mouseout			когда мышь наводится на / покидает элемент.
mouseenter / mouseleave		Как mouseover / mouseout, но пререходы внутри элемента на его потомков не считаются.
													mouseenter / mouseleave не всплывают! т.е. их нельзя делегировать

Все события мыши имеют координаты двух видов:
Координаты относительно окна: clientX/clientY. (event.clientX / event.clientY)
Координаты относительно документа: pageX/pageY.

? События клавиатуры:
keydown - нажатие
keyup - отпускание
event.key				получить символ (он может различаться (регистр, язык))
event.code			получить физический код клавиши (всегда будет тот же)

Клавиши-модификаторы (true если нажаты): altKey, ctrlKey, shiftKey и metaKey (Mac).
Если вы планируете обработать Ctrl, то не забудьте, что пользователи Mac обычно используют Cmd,
поэтому лучше проверить if (e.metaKey || e.ctrlKey).

автоповтор при зажатии клавиши event.repeat вернет true

? Другие события:
scroll							это событие, когда пользователь прокручивает страницу или элемент в любой плоскости
DOMContentLoaded		когда HTML загружен и обработан, DOM документа полностью построен и доступен. Навешивается только на document
load								как DOMContentLoaded, но после загрузки стилей.  Навешивается только на window
submit							пользователь отправил форму <form>.
focus								пользователь фокусируется на элементе, например нажимает на <input>.
transitionend				когда CSS-анимация завершена.

? Отмена действия браузера по умолчанию
event.preventDefault()		если обработчик был назначен через .addEventListener
onclick="return false"		если обработчик был назначен через on<событие>

? Событие указателя	Аналогичное событие мыши
События указателя позволяют одновременно обрабатывать действия с помощью мыши, касания и пера, в едином фрагменте кода.
pointerdown						mousedown
pointerup							mouseup
pointermove						mousemove
pointerover						mouseover
pointerout						mouseout
pointerenter					mouseenter
pointerleave					mouseleave
pointercancel					-
gotpointercapture			-
lostpointercapture		-

* Всплытие и погружение ==================================================================================//

При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target).
Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики,
	поставленные через addEventListener(...., true), где true – это сокращение для {capture: true}.
Далее обработчики вызываются на целевом элементе.
Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики,
	поставленные через on<event> и addEventListener без третьего аргумента или с третьим аргументом равным false.

Каждый обработчик имеет доступ к свойствам события event:
event.target – самый глубокий элемент, на котором произошло событие.
event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
event.eventPhase – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).

Отличия event.target от this (=event.currentTarget):
event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
this (=event.currentTarget) – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

Всплытие идёт с «целевого» элемента прямо наверх, вызывая все обработчики на своём пути.
Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется,
так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.
event.stopPropagation() препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.
Для того, чтобы полностью остановить обработку, существует метод event.stopImmediatePropagation().
Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

* Формы ==================================================================================================//

document.forms										Свойства для навигации по формам
document.forms[name/index]				доступ к форме
form.elements[name/index]					доступ к элементам формы (или использовать form[name/index])
element.form											Элементы хранят ссылку на свою форму в свойстве form.
(input, textarea, select).value		получить значения элементов формы (не использовать: textarea.innerHTML)
input.checked											для чекбоксов и переключателей (true / false)

input.checked = true							присвоить значение
input.value = 'new value'					присвоить значение

Все элементы управления формы, как бы глубоко они не находились в форме,
	доступны в коллекции form.elements

? <select> имеет 3 свойства.
Они дают три разных способа установить значение в <select>:
	select.options					коллекция из подэлементов <option> (true / false)
	select.value						значение выбранного в данный момент <option> (значение)
	select.selectedIndex 		номер выбранного <option> (номер нужного <option>)

<select> позволяет нам выбрать несколько вариантов одновременно, если у него стоит атрибут multiple.
	В этом случае нужно использовать свойство selected у подэлементов <option>

Короткий синтаксис для создания элемента <option>:
	option = new Option(text, value, defaultSelected, selected)
		text							текст внутри <option>
		value							значение
		defaultSelected		если true, то ставится HTML-атрибут selected
		selected					если true, то элемент <option> будет выбранным.
defaultSelected и selected обычно ставят в true или не ставят вовсе (т.е. false)

? Фокусировка: focus/blur
События focus и blur								срабатывают на фокусировке/потере фокуса элемента.
Методы elem.focus() и elem.blur()		устанавливают/снимают фокус.
document.activeElement							получить текущий элемент с фокусом

focus/blur не всплывают.
Но можно использовать фазу перехвата или focusin/focusout.
focusin/focusout должны использоваться с elem.addEventListener, но не с on<event>

? События: change, input, cut, copy, paste
change						Значение было изменено.Для текстовых полей срабатывает при потере фокуса.
input							Срабатывает при каждом изменении значения. Запускается немедленно, в отличие от change.
cut/copy/paste		Действия по вырезанию/копированию/вставке. Действие можно предотвратить.
									event.clipboardData	предоставляет доступ на чтение/запись в буфер обмена…

event.preventDefault() для предотвращения действия по умолчанию,
	и в итоге ничего не скопируется/не вставится.

? Отправка формы: событие и метод submit
При отправке формы срабатывает событие submit
Есть два основных способа отправить форму:
	Первый – нажать кнопку <input type="submit"> или <input type="image">.
	Второй – нажать Enter, находясь на каком-нибудь поле.
Оба действия сгенерируют событие submit на форме.
Обработчик может проверить данные, и если есть ошибки, показать их и вызвать event.preventDefault(), тогда форма не будет отправлена на сервер.

form.submit()			позволяет инициировать отправку формы из JavaScript
Чтобы отправить форму на сервер вручную, мы можем вызвать метод form.submit().
При этом событие submit не генерируется.

* Загрузка документа и ресурсов ==================================================================================//

? События загрузки страницы:
DOMContentLoaded					генерируется на document, когда DOM готов.
load											на window генерируется, когда страница и все ресурсы загружены.
beforeunload							на window генерируется, когда пользователь покидает страницу.
unload										на window генерируется, когда пользователь окончательно уходит.

document.readyState – текущее состояние документа,
	изменения можно отследить с помощью события readystatechange:
		loading – документ грузится.
		interactive – документ прочитан, происходит примерно в то же время, что и DOMContentLoaded, но до него.
		complete – документ и ресурсы загружены, происходит примерно в то же время, что и window.onload, но до него.

? Скрипт defer
Атрибут defer сообщает браузеру, что он должен запустить скрипт,
	когда DOM дерево будет полностью построено.(<script defer src="https:...)
Скрипты с defer никогда не блокируют страницу.
Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события DOMContentLoaded.
Отложенные с помощью defer скрипты сохраняют порядок относительно друг друга, как и обычные скрипты.
Атрибут defer предназначен только для внешних скриптов:
	Атрибут defer будет проигнорирован, если в теге <script> нет src.
На практике defer используется для скриптов,
	которым требуется доступ ко всему DOM и/или важен их относительный порядок выполнения.

? Скрипт async
Атрибут async (<script async src="https...) означает, что скрипт абсолютно независим:
	Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.
	Событие DOMContentLoaded и асинхронные скрипты не ждут друг друга:
		DOMContentLoaded может произойти как до асинхронного скрипта так и после
	Остальные скрипты не ждут async, и скрипты c async не ждут другие скрипты.
	Если есть несколько скриптов с async, они могут выполняться в любом порядке.
Атрибут async предназначен только для внешних скриптов:
	Атрибут async будет проигнорирован, если в теге <script> нет src.
На практике async хорош для независимых скриптов, например счётчиков и рекламы,
	относительный порядок выполнения которых не играет роли.

? Загрузка ресурсов: onload и onerror
Браузер позволяет отслеживать загрузку сторонних ресурсов: скриптов, ифреймов, изображений и др.
Для этого существуют два события:
	load – успешная загрузка. Оно срабатывает после того, как скрипт был загружен и выполнен.

	error – во время загрузки произошла ошибка:
		script.onerror = function() {
			alert("Ошибка загрузки " + this.src); // Ошибка загрузки https://example.com/404.js
		};
	Мы не можем получить описание HTTP-ошибки.
	Мы не знаем, была ли это ошибка 404 или 500, или какая-то другая.
	Знаем только, что во время загрузки произошла ошибка.

Обработчики onload/onerror отслеживают только сам процесс загрузки.
Ошибки обработки и выполнения загруженного скрипта ими не отслеживаются.
Чтобы «поймать» ошибки в скрипте, нужно воспользоваться глобальным обработчиком window.onerror.

События load и error также срабатывают и для других ресурсов, а вообще, для любых ресурсов, у которых есть внешний src.
Единственное исключение – это <iframe>: по историческим причинам срабатывает всегда load
	вне зависимости от того,как завершилась загрузка, даже если страница не была найдена.









!  ====================================================================================================//








*/