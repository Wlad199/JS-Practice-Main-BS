/*
React (https://unpkg.com/react@18/umd/react.development.js)
React DOM (https://unpkg.com/react-dom@18/umd/react-dom.development.js)
Babel (https://unpkg.com/babel-standalone@6/babel.min.js)

npm commands
	npm init 															создать package.json
	npm i (npm install)										установить зависимости
	npm i hello-world-npm@1.1.1						с выбором версии 
	npm i hello-world-npm@1.1.1 -Е				с точным выбором версии (без ^) 
	npm i hello-world-npm -D (--save-dev)	с установить в devDependencies 
	-g (лучше через npx)									Установить глобально
	npm un ... (uninstall)								Удалить

1 .Install NODE
2. Install CRA (Create React APP)
	(npx create-react-app my-app)
3. Запустить CRA.
	npm run start (build)
4. Создать, если надо package.json
	npm init
5. Установить зависимости (node modules)
	npm i (npm install)
6. Устанавливать библиотеки:
	Например: npm i hello-world-npm
	Или вручную добавить в package.json и npm i
	С выбором версии npm i hello-world-npm@1.1.1
	С точным выбором версии (без ^) npm i hello-world-npm@1.1.1 -Е
	С установить в devDependencies npm i hello-world-npm -D (или: --save-dev)
	Установить глобально: -g (лучше через npx)
 Удалить: npm un ... (uninstall)



Внутри jsx можно использ. только map или reduce (filter только с последующей конвертацией в react)
	т.к. они возвращают результат. За пределами jsx можно испозьз. что угодно.

Вместо class используется className
Подключение стилей: import './style.css';

Если внутри jsx использ Map() то елементам массива нужен уникальный ключ key={}
В случае, если исходный массив точно не будет меняться - то можно использ второй аргумент ф-ции Map - index: Map((user, index)=>...)
В случае если ключи в массиве уникальны - можно использ их
В остальных случаях лучше генерировать ключи самостоятельно на основе данных

?  =================//
Для bable нужно указать type="text/babel" в подключаемом скрипте с компонентом

Импорты из внешних пакетов следует размещать в начале файла, а затем свои импорты.

Для рендеринга React-элемента, сперва передайте DOM-элемент в ReactDOM.createRoot(),
	далее передайте React-элемент в root.render():

	const root = ReactDOM.createRoot(
		document.getElementById('root')
	);
	const element = <h1>Hello, world</h1>;
	root.render(element);
	
? Events =================//
onSubmit				отправка формы
onClick					обработчик кликов
onChange				обработчик инпутов
onMouseEnter		мышь наведена
onMouseLeave		мышь ушла
onMouseDown			мышь нажата
onMouseUp				мышь отжата

? style =================//
<div style={{ backgroundColor: 'green', display: 'inline-block' }}>text</div>
React автоматически добавит суффикс «px» к свойствам стилей с числовым значением.
Если вы хотите использовать единицы измерения, отличные от «px»,
	укажите значение в виде строки с желаемой единицей измерения. 

? getDerivedStateFromProps Поместить пропс в стэйт =================//
static getDerivedStateFromProps(props, state)		
getDerivedStateFromProps вызывается непосредственно перед вызовом метода render,
	как при начальном монтировании,так и при последующих обновлениях.
Он должен вернуть объект для обновления состояния или null, чтобы ничего не обновлять.
Этот метод существует для редких случаев, когда состояние зависит от изменений в пропсах

	static getDerivedStateFromProps(props, state) {
		return {
			s1: props.a1,
			s2: props.a2
		}
	}

? componentDidMount() изменение после монтирования элемента =================//
React будет вызывать componentDidMount, когда ваш компонент будет добавлен (смонтирован) на экран.
Это обычное место для начала получения данных, установки подписок или манипулирования узлами DOM.
Если вы реализуете componentDidMount, вам обычно необходимо реализовать другие методы жизненного цикла, чтобы избежать ошибок.
Например, если componentDidMount считывает некоторые состояния или пропсы,
	вам также необходимо реализовать componentDidUpdate для обработки их изменений
	и componentWillUnmount для очистки того, что делал componentDidMount.

	componentDidMount() {
		this.setState({
			s3: this.state.s1 * this.state.s2
		})
	}

? Хуки =================//
Хуки — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов.
Хуки не работают внутри классов — они дают вам возможность использовать React без классов.
Хуки — это функции JavaScript, которые налагают два дополнительных правила:
	1. Хуки следует вызывать только на верхнем уровне.
		Не вызывайте хуки внутри циклов, условий или вложенных функций.
	2. Хуки следует вызывать только из функциональных компонентов React.
		Не вызывайте хуки из обычных JavaScript-функций.
		Есть только одно исключение, откуда можно вызывать хуки — это ваши пользовательские хуки.

? Other =================//
defaultChecked={true} 				для назначения по-умолчанию для чекбоксов
checked={this.state.checkbox} для управления через стейты
<input defaultValue='someText' /> назначить input значение по умолчанию


? questions  =================//
OOP
Замыкания
props & state
Жизненый цикл компонентов
Expression & jsx
Forms
Git(Залить, скачать, обновиться, перезаписать, свести)




! SomeLessons===================================================

REACT 10
const USERS = [
	{ name: 'Alex', age: 18, id: 562 },
	{ name: 'John', age: 58, id: 552 },
	{ name: 'Bob', age: 15, id: 592 },
	{ name: 'Bob', age: 11, id: 762 },
]
1. Для массива вывести имена пользователей в документ
	Создать уникальные ключи:
	через имена
	через Map(), используя index
	Написать функцию, генерирующую уникальные ключи (Alex_18_562)

	
2. Создать кнопку и инпут через компоненты
	Повесить обработчики событий
	Вывести в консоль события event & value
	Завернуть все в форму и навесить на нее сабмит

! Stach =================//

1. Вывести на экран текст с переменными (09-10st)
			(I don't have any animals!!!
			My Wolf is 89 year old)`
	Менять текст с помощью свойства hasPet(true/false)

2. Создать кнопку, генерирующую число и вывести на экран (11st)
	Добавить возможность менять границы чисел через maxNum="300"

3. Создать 4 кнопки, увеличивающие счетчик (12st)
	Переделать кнопки с помощью map (13st)

4. Создать массив с помощью https://mockaroo.com/  (14st)
	Сгенерировать карточки пользователей ()  (id firstТame, lastТame, email, img )
		Создать компонент Persons, который пройдет методом map и вернет массив карточек,
		в котором будет компонент Person. Person будет наполнять карточки данными

! ItGid =================//

1. Вывод ассоциативного массива.
	Создайте компонент Nav, в него передайте props.nav 
		куда добавьте ассоциативный массив в формате пункт меню - ссылка. 
		Все ссылки поставить как якоря (#). Данные в Nav должны передаваться из файла index.js. 
		Вывести указанный массив на страницу.
			let nav = {
				'main': '/index',
				'about': '/about',
				'price': '/price'
			}
	Добавьте компонент footer.
		Компонент должен принимать props - контакты (массив телефонов) и адрес:
		массив из трех строк: город, улица, дом - офис.
		Все данные должны передаваться через index.js.
		Также передавайте в footer заголовок для вывода. 

2. Добавьте параграф.
		При клике по кнопке - выводите текст button work в параграф.
	Добавьте кнопку с текстом Count.
		Создайте state.count = 0 и выведите его на страницу в параграф.
		Добавьте на кнопку Count событие, которое будет вызывать метод увеличивающий state.count на единицу при каждом нажатии.
		Добавьте кнопку ResetCount обновляющую count.

3. Input, select
	Добавьте input и параграф.
		При вводе текста в input - выводите в параграфе вводимый текст.
		Если длина вводимого текста меньше 6 символов - то выводите на страницу предупреждение о том, что длина меньше 6.
	Добавьте checkbox
		При изменении его состояния выводите checkbox checked или checkbox unchecked.
	Добавьте выпадающий список.
		При изменении состояния - выводите value выбранного на страницу.
	Добавьте div и кнопку.
		При нажатии кнопки - увеличивайте ширину div на 3 px.
		Добавьте кнопку Reset позволяющую сбрасывать состояние до начальной ширины.
	Добавьте полнузок.
		При изменении ползунка выводите его value на страницу.
	Добавьте кнопку и изображение.
		При клике на кнопку скрывайте изображение, при повторном клике - показывайте.

4. Формы.
		Вывести value из input в блок
		Рендерить блок только когда в value что-то есть
		Создайте форму. Форма должна содержать:
			input[text]
			input[number]
			input[range]
			textarea
			select
			input[submit]
		Написать одну ф-ю, которая будет обрабатывать все inputs
			и выводить в формате: Имя - значение

5. getDerivedStateFromProps() & componentDidMount()
	Передайте из index.js props a1 = 5 и a2 =10 в компонент App.js.
		Выведите их на страницу как пропсы.
	Используя getDerivedStateFromProps() присвойте пропсы a1 и a2 в state s1 и s2 соответственно.
		Выведите на страницу под state.
	В конструкторе объявите state s3 который будет равен s1 умноженному на s2.
		Выведите его на страницу.
	Создайте компонент App2.js и подключите его в App.js.
		Передайте s3 в качестве пропса z1 внутрь App2.
		Выведите его на страницу в App2 как props.
	В App2 присвойте z1 в state y1. Выведите y1*10 на страницу.












*/
