/*
! Question ====================================================================================================//

! useContext
! Custom Hooks
! Children

! High Order Components
! React Context
! Render props
! CSS Modules
! Shadow Dom
! FORMS: React hook form / Formik
! Серверный рендеринг (Варианты рендеринга)
! Next JS

!  ====================================================================================================//
Roadmap (https://roadmap.sh/react)
Вопросы и ответы (https://it-dev-journal.ru/articles/top-10-voprosov-na-sobesedovanii-react-js)
Вопросы и ответы (https://roadmap.sh/questions)
react slills (https://practicum.yandex.ru/react/?utm_source=yandex&utm_medium=cpc&utm_campaign=Yan_Net_RF_Prog_reac_b2c_Gener_Regular_1_460_upskill&utm_content=sty_context%3As_yandex.ru%3Acid_103839286%3Agid_5365194792%3Akw_%3Apid_61579094%3Aaid_15590379430%3Acrid_0%3Arid_61579094%3Ap_0%3Apty_none%3Amty_%3Amkw_%3Adty_desktop%3Acgcid_17978231%3Arn_Ярославль%3Arid_16&utm_term=&yclid=14094681718427746303)



? Base
## Что такое React ?
React - это открытая (с открытым исходным кодом) JavaScript-библиотека для фронтенда, 
	предназначенная для создания пользовательских интерфейсов, 
	особенно, если речь идет о создании одностраничных приложений (Single Page Applications, SPA).
## Назовите основные особенности React
	1. Использование VirtualDOM (виртуальной объектной модели документа) вместо RealDOM (настоящий или реальный DOM), 
		поскольку манипуляции с RealDOM являются дорогостоящими с точки зрения производительности.
	2. Поддержка рендеринга на стороне сервера (Server Side Rendering, SSR).
	3. Следование принципу однонаправленного потока или связывания данных (one-directional data flow).
	4. Использование переиспользуемых (reusable) компонентов пользовательского интерфейса 
		(User Interface, UI) для формирования слоя представления.
## Какие преимущества предоставляет использование React?
	1. Повышение производительности приложения благодаря виртуальному DOM.
	2. JSX облегчает написание и чтение кода.
	3. Возможность рендеринга как на стороне клиента, так и на стороне сервера.
	4. Возможность относительно простой интеграции с фреймворками, поскольку React - это всего лишь библиотека.
	5. Возможность быстрого юнит и интеграционного тестирования с помощью таких инструментов, как Jest.
## Какие ограничения имеются в React?
	1. React - это всего лишь библиотека, отвечающая за слой представления, а не полноценный фреймворк.
	2. Его трудно изучать новичкам в веб-разработке (впрочем, как и любой другой фреймворк).
	3. Интеграция с традиционными MVC-фреймворками требует дополнительных настроек.
	4. Код является более сложным из-за встроенных шаблонов и JSX.
	5. Большое количество мелких компонентов приводит к сложности в проектировании и построении архитектуры приложения.
## В чем разница между обработкой событий в HTML и React?
	1. В HTML название события указывается строчными буквами (в нижнем регистре)
		В React для этого используется "верблюжий стиль" (camelCase)
	2. В HTML можно вернуть false для отключения поведения по умолчанию
		В React необходимо явно вызывать метод preventDefault
	3. В HTML необходимо вызывать функцию с помощью (). В React этого делать не нужно.
## Как работает виртуальный DOM?
	Виртуальный DOM (VDOM) — это подход для при котором "виртуальное" представление пользовательского интерфейса хранится в памяти. 
		И этот виртуальный DOM синхронизируется с "настоящим" DOM. 
		В React для этого используется библиотеки (react-dom). 
		Сам этот процесс называется согласованием (reconciliation).
	1. При любом изменении внутренних данных пользовательский интерфейс меняется в представлении виртуального DOM.
	2. Затем вычисляется разница между предыдущим и новым представлениями.
	3. После этого обновляются только те части реального DOM, которые подверглись изменениям.
## В чем разница между React и ReactDOM?
	Пакет react содержит React.createElement(), React.Component, React.Children
		и другие вспомогательные функции, связанные с элементами и компонентами.
		О них можно думать как об изоморфных или универсальных помощниках в создании компонентов.
	Пакет react-dom содержит ReactDOM.render(), а в react-dom/server у нас имеется рендеринг на стороне сервера,
		обеспечиваемый такими методами как ReactDOMServer.renderToString() и ReactDOMServer.renderToStaticMarkup().
## Почему ReactDOM отделен от React?
	Ядро React не должно быть тесно связано с браузером или DOM.
	Для обеспечения рендеринга в разных средах выполнения кода, 
		команда React разделила основной пакет React на две части: react и react-dom. 
	Это позволяет легко создавать компоненты, которые могут использоваться как в веб, так и в мобильной версиях приложения.
## Что такое согласование?
	После изменения состояния или пропов компонента, React определяет, 
		нуждается ли DOM в обновлении посредством сравнения нового элемента с предыдущим. 
	Когда эти элементы отличаются, React обновляет DOM. Данный процесс называется согласованием (reconciliation).
## Что такое JSX?
	JSX (JavaScript и XML) - это XML-подобный синтаксис, расширяющий возможности ECMAScript.
	По сути, он является синтаксическим сахаром для функции React.createElement, 
		совмещая выразительность JavaScript с HTML-подобным синтаксисом разметки.
	За правильный парсинг и дальнейшую обработку отвечает babel.
	Если название типа элемента начинается с маленькой буквы, он ссылается на встроенный компонент,
		например, <div> или <span>
	Типы, начинающиеся с заглавной буквы, такие как <SomeComponent />, 
		компилируются в React.createElement(SomeComponent) и соответствуют компоненту, 
		который был объявлен или импортирован в JavaScript-файле.
## Что такое фрагмент? Почему фрагмент лучше, чем дополнительный div?
	Фрагмент (fragment) - это распространенный паттерн в React, 
		который используется в компонентах, возвращающих несколько элементов.
	Фрагменты позволяют группировать дочерние элементы без создания лишних DOM-узлов
	Фрагменты немного быстрее и используют меньше памяти. 
	Реальная польза от этого ощущается в очень больших и глубоких деревьях элементов.
	Некоторые механизмы CSS, например, Flexbox и Grid используют связь предок-потомок, 
		поэтому добавление дополнительных div может поломать макет страницы.
	Меньшее количество элементов облегчает инспектирование DOM.

## Почему компоненты React могут иметь только один корневой элемент?
	Компонент React в конце будет скомпилирован в функцию рендеринга, и возвращаемое значение функции может быть только одно. 
		Если он не обернут в отдельный корневой узел, несколько значений будут возвращаться параллельно, что не допускается в JavaScript.
	Виртуальный DOM React представляет собой древовидную структуру, и корневой узел дерева может быть только один. 
		При наличии нескольких корневых узлов невозможно подтвердить, какое дерево нужно обновить.

? Component / Props / State
## Когда лучше использовать классовый компонент, а когда функциональный?
	Если компонент нуждается в состоянии или методах жизненного цикла, тогда используйте классовый компонент, 
		иначе, используйте функциональный компонент.
	В React 16.8 были представлены хуки, позволяющие использовать состояние, 
		методы жизненного цикла и другие возможности классовых компонентов в функциях. 
	В настоящее время классовые компоненты в React почти не используются.
	##  Что такое пропы?
	Пропы (props) - это входные данные для компонента.
	Это простые значения (примитивы) или объект, содержащий несколько значений, 
		которые передаются компонентам при их создании с помощью синтаксиса, похожего на атрибуты HTML-тегов.
	Основное назначение пропов в React заключается в предоставлении компоненту следующего функционала:
		1. Передача данных компоненту.
		2. Вызов изменения состояния.
		3. Использование через this.props.propName внутри метода render компонента.
## Что такое состояние? 
	Состояние (state) - это объект, содержащий некоторую информацию, 
		которая может измениться в течение жизненного цикла компонента.
	Мы всегда должны стараться делать состояние настолько простым, насколько это возможно,
		и минимизировать количество компонентов без состояния.
	Состояние похоже на проп, но оно является приватным (замкнуто в своей области видимости) и полностью контролируется компонентом, 
		т.е. оно недоступно для других компонентов, кроме того, которому оно принадлежит и которое его определяет.
## В чем разница между состоянием и пропами?
	И props, и state являются обычными JavaScript-объектами. 
	Несмотря на то, что они оба содержат информацию, которая используется при рендеринге компонента, функционал у них разный. 
	Пропы передаются компоненту подобно аргументам, передаваемым функции, 
		а состояние управляется компонентом как переменные, объявленные внутри функции.
## Что такое key и в чем заключаются преимущества его использования?
	key - это специальный строковый атрибут, который следует использовать при создании списков элементов. 
	Проп key помогает React определять, какие элементы подверглись изменениям, были добавлены или удалены.
	Использовать индексы в качестве ключей не рекомендуется, если порядок расположения элементов может измениться.
		Это может негативно сказаться на производительности, а также привести к проблемам с состоянием компонента.
## Что такое управляемые/неуправляемые компоненты?
	Компоненты, которые управляют инпутами формы для текущего пользователя, называются управляемыми. 
		Любое изменение состояния имеет соответствующий обработчик.
		Для обработки форм рекомендуется использовать управляемые компоненты.
	Неуправляемые компоненты - это компоненты, которые имеют собственное состояние. 
		При необходимости получения значения их текущего состояния используются ссылки на DOM-элементы. 
		Это больше похоже на обычный HTML.
## Что такое подъем состояния?
	Когда несколько компонентов нуждаются в использовании одних и тех же изменяющихся данных, 
		рекомендуется поднимать совместно используемое состояние до ближайшего общего предка, 
		вместо дублирования состояния в каждом потомке.
## Что такое компонент высшего порядка?
	Higher-order component (HOC) - это функция, принимающая компонент и возвращающая новый модифицированный компонент. 
	Это паттерн, производный от композиционной природы React.
	Мы называем такие компоненты чистыми, поскольку они могут принимать и динамически предоставлять дочерние компоненты, 
		но не меняют и не копируют их поведение.
	HOC обычно используются для:
		1. Обеспечения возможности повторного использования кода, логики, а также для абстрагирования шаблонов.
		2. Отложенного рендеринга.
		3. Абстрагирования и манипуляции состоянием.
		4. Манипуляции пропами.

## Pure Components (Чистые компоненты)
	Компонент является чистым, если он гарантированно возвращает один и тот же результат при одинаковых пропсах и состоянии.
	Чистые компоненты имеют улучшенную производительность за счет поверхностного сравнения пропсов и состояния.

## Что такое контекст?
	Context API предоставляет возможность передавать данные в дереве компонента 
		без необходимости передачи пропов на каждом уровне вручную.
## Что такое children?
	Потомки - это проп (this.props.children), позволяющий передавать одни компоненты другим как любые другие пропы. 
	Дерево компонентов, размещаемое между открывающим и закрывающим тегами, передается компоненту в качестве пропа children.
	Для работы с этим пропом в React API существуют такие методы как 
		React.Children.map, React.Children.forEach, React.Children.count, React.Children.only и React.Children.toArray.
## Что такое примеси?
	Примеси или миксины (mixins) - это способ обеспечения совместного использования 
		одной функциональности совершенно разными компонентами.
	Примеси не следует использовать, их можно заменить компонентами высшего порядка или декораторами.
	В настоящее время примеси признаны устаревшими.

! Life Circle
## Назовите стадии жизненного цикла компонента
	Жизненный цикл компонента состоит из 3 стадий:
		Монтирование: компонент готов к встраиванию в браузерный DOM. 
			Эта стадия охватывает инициализацию в constructor(), 
			а также методы жизненного цикла getDerivedStateFromProps, render и componentDidMount.
		Обновление: на данной стадии компонент обновляется либо из-за получения новых пропов, 
			либо из-за обновления состояния с помощью setState() или forceUpdate().
			Эта стадия охватывает такие методы жизненного цикла как: 
			getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate и componentDidUpdate.
		Размонтирование: на этой последней стадии компонент удаляется из браузерного DOM. 
			Данная стадия включает метод жизненного цикла componentWillUnmount.

	Следует отметить, что в React также имеются особые стадии применения изменений к DOM:
		Рендеринг: компонент рендерится без каких-либо побочных эффектов. 
			Это применяется в отношении "чистых" компонентов. 
			На данной стадии React может приостанавливать, прерывать или перезапускать рендеринг.
		Pre-commit: перед обновлением компонента существует момент, когда React читает DOM через getSnapshotBeforeUpdate().
		Commit: React изменяет DOM и выполняет завершающие методы жизненного цикла, такие как:
			componentDidMount при монтировании, componentDidUpdate при обновлении и componentWillUnmount при размонтировании.

## Назовите методы жизненного цикла
	componentDidMount: выполняется после первого рендеринга, здесь выполняются AJAX-запросы, 
		обновляется DOM или состояние компонента, регистрируются обработчики событий;
	shouldComponentUpdate: определяет, должен ли компонент обновляться. Значением по умолчанию является true. 
		Если компонент не нуждается в повторном рендеринге при изменении состояния или пропов, можно вернуть false. 
		Это подходящее место для улучшения производительности, 
		позволяющее предотвратить ненужные рендеринги при получении компонентом новых пропов;
	componentDidUpdate: в основном, используется для обновления DOM в соответствии с изменениями состояния или пропов;
	componentWillUnmount: используется для отмены сетевых запросов или удаления обработчиков событий, связанных с компонентом.
	getDerivedStateFromProps: запускается перед вызовом метода render и при каждом повторном рендеринге. 
		Он используется в редких случаях, когда требуется производное состояние (derived state)
	getSnapshotBeforeUpdate: выполняется перед применением результатов рендеринга к DOM. 
		Любое значение, возвращенное этим методом, передается в componentDidUpdate(). 
		Это может быть полезным для получения информации из DOM, например, позиции курсора или величины прокрутки;

## Назовите методы жизненного цикла компонента, относящиеся к монтированию
	При создании и встраивании компонента в DOM методы жизненного цикла вызываются в следующем порядке:
		constructor.
		static getDerivedStateFromProps.
		render.
		componentDidMount.

## В каком порядке вызываются методы жизненного цикла при повторном рендеринге компонента?
	Обновление компонента может быть вызвано изменением пропов или состояния. 
	При повторном рендеринге методы вызываются в следующим порядке:
		static getDerivedStateFromProps.
		shouldComponentUpdate.
		render.
		getSnapshotBeforeUpdate.
		componentDidUpdate.

## Что вызывает обновление компонента?
	Обновление компонента вызывают изменение состояния и изменение пропсов. 
	В классовых компонентах еще есть forceUpdate (следует использовать только в крайних случаях).
	Изменение состояния не будет приводить к обновлениям, если новое значение состояния не изменилось. 
	Если мутировать состояние напрямую это тоже не приведет к повторному рендеру
	Когда родительский компонент рендерится, дочерние компоненты рекурсивно тоже будут ререндериться. 
	Скорее всего некоторые компоненты в этой цепочке вернут тот же самый результат, т.е. не изменятся. 
		Поэтому они не будут перерисованы в DOM. 
		Но React все равно должен сделать рендер, чтобы определить эти различия, сравнить и определить нужна перерисовка или нет.

## В чем разница memo и useMemo?
	memo — это компонент высшего порядка.
		Он нужен для повышения производительности и подходит для случаев, 
		когда компонент рендерит одинаковый результат при одних и тех же значениях пропсов. 
		В этом случае результат будет мемоизирован. 
		Это значит, что React будет использовать результат последнего рендера, избегая повторного рендеринга.
		При использовании memo пропсы по умолчанию сравниваются поверхностно. 
		Можно передать свою функцию сравнения в качестве второго аргумента (если нужно контролировать сравнение).
	useMemo - это хук, который возвращает мемоизированное значение функции, которая делает долгие вычисления. 
		Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере. 
		useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось.

*/
