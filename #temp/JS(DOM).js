/*
! DOM ====================================================================================================//

? Получить Узел =================//

<html> = document.documentElement
<head> = document.head
<body> = document.body

Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.
Есть два основных набора ссылок:
	1. Для всех узлов:
	parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
	Проверить наличие узла: hasChildNodes (element.hasChildNodes())
	2. Только для узлов-элементов:
	parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.

childNodes похож на массив, на самом деле это не массив,
	а коллекция – особый перебираемый объект-псевдомассив. Коллекции живые.
И есть два важных следствия из этого:
	1. Для перебора коллекции мы можем использовать for..of
	2. Методы массивов не будут работать, потому что коллекция – это не массив
		Если нам хочется использовать именно методы массива,
		то мы можем создать настоящий массив из коллекции, используя Array.from:
			Array.from(document.body.childNodes) // сделали массив

В DOM значение null значит «не существует» или «нет такого узла».
Не используйте цикл for..in для перебора коллекций!!!

parentElement возвращает родитель-элемент, а parentNode возвращает «любого родителя».
Обычно эти свойства одинаковы: они оба получают родителя.
За исключением document.documentElement:
	document.documentElement.parentNode; // выведет document
	document.documentElement.parentElement; // выведет null

? Поиск =================//

Есть 6 основных методов поиска элементов в DOM:
Метод											Ищет по...		Ищет внутри элемента?	Возвращает живую коллекцию?
querySelector							CSS-selector						✔												-
querySelectorAll					CSS-selector						✔												-
getElementById								id									-												-
getElementsByName						name									-												✔
getElementsByTagName			tag or '*'							✔												✔
getElementsByClassName			class									✔												✔

Безусловно, наиболее часто используемыми в настоящее время являются методы querySelector и querySelectorAll,
	но и методы getElement(s)By* могут быть полезны в отдельных случаях, а также встречаются в старом коде.
Метод getElementById можно вызвать только для объекта document.
	Он осуществляет поиск по id по всему документу.

Все методы "getElementsBy*" возвращают живую коллекцию.
	Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.
querySelectorAll возвращает статическую коллекцию. Это похоже на фиксированный массив элементов.

Псевдоклассы в CSS-селекторе, в частности :hover и :active, также поддерживаются.
Например, document.querySelectorAll(':hover') вернёт коллекцию
	(в порядке вложенности: от внешнего к внутреннему) из текущих элементов под курсором мыши.

elem.matches(css)				проверяет, удовлетворяет ли элемент CSS-селектору.Возвращает true или false
elem.closest(css)				ищет ближайшего по иерархии предка, соответствующему данному CSS-селектору.
												Возвращает либо предка, либо null Сам элемент также включён в поиск.
elemA.contains(elemB)		вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB.

? Получить содержимое =================//

DOM-узлы – это обычные JavaScript объекты.
Для наследования они используют классы, основанные на прототипах.

nodeType - «старомодный» способ узнать «тип» DOM-узла.
Его значением является цифра:
	elem.nodeType == 1 для узлов-элементов,
	elem.nodeType == 3 для текстовых узлов,
	elem.nodeType == 9 для объектов документа,
В современных скриптах, чтобы узнать тип узла, мы можем использовать метод instanceof

elem.nodeName / elem.tagName		узнать имя его тега из свойств
tagName есть только у узлов-элементов, а nodeName может что-то сказать о других типах узлов.
Если мы имеем дело только с элементами, то можно использовать tagName или nodeName, нет разницы.
Имена тегов (кроме XHTML) всегда пишутся в верхнем регистре

innerHTML				Внутреннее HTML-содержимое узла-элемента в виде строки. Можно изменять.
outerHTML				Полный HTML узла-элемента. Как innerHTML плюс сам элемент.
								Запись в elem.outerHTML не меняет elem. Вместо этого она заменяет его во внешнем контексте.
textContent			Текст внутри элемента: HTML за вычетом всех <тегов>.
								Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст.
								Можно использовать для защиты от вставки произвольного HTML кода.
hidden 					Когда true, делает то же самое, что и CSS display:none. (elem.hidden = true)

Свойство innerHTML есть только у узлов-элементов.
У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и data

У DOM-элементов есть дополнительные свойства, зависящие от класса:
value						значение для <input>, <select> и <textarea> (HTMLInputElement, HTMLSelectElement…).
href						адрес ссылки «href» для <a href="..."> (HTMLAnchorElement).
id							значение атрибута «id» для всех элементов (HTMLElement).

? Методы для создания узлов =================//

document.createElement("tag")			создаёт элемент с заданным тегом,
document.createTextNode(value)		создаёт текстовый узел (редко используется)
elem.cloneNode(deep)							клонирует элемент, если deep==true, то со всеми дочерними элементами

Вставка и удаление (nodes or strings):
node.before					вставляет прямо перед node
node.prepend				вставляет в node в начало
node.append					вставляет в node в конец
node.after					вставляет сразу после node
node.replaceWith		заменяет node
node.remove()				удаляет node

elem.insertAdjacentHTML(where, html) вставляет HTML в зависимости от where:
"beforebegin"				вставляет html прямо перед elem
"afterbegin"				вставляет html в elem в начало
"beforeend"					вставляет html в elem в конец
"afterend"					вставляет html сразу после elem

elem.insertAdjacentText				строка text вставляется «как текст», вместо HTML
elem.insertAdjacentElement		вставляет элемент elem
insertAdjacentText & insertAdjacentElement используются редко

Если нам нужно переместить элемент в другое место – нет необходимости удалять его со старого.
Все методы вставки автоматически удаляют узлы со старых мест.
	second.after(first); // берёт #second и после него вставляет #first

? Css =================//

Для управления классами существуют два DOM-свойства:
elem.className		строковое значение, удобно для управления всем набором классов
elem.classList		(add/remove/toggle/contains) для управления отдельными классами
	classList является перебираемым, можно перечислить все классы при помощи for..of

Чтобы изменить стили(style & style.cssText):
Свойство style является объектом со стилями в формате camelCase
	Чтение и запись в него работают так же, как изменение соответствующих свойств в атрибуте "style"
	Свойство style оперирует только значением атрибута "style", без учёта CSS-каскада.
	Поэтому, используя elem.style, мы не можем прочитать ничего, что приходит из классов CSS.
		background-color: 'red'	=> elem.style.backgroundColor = 'red'
		display: "none"					=> elem.style.display = "none"
		вернуть обратно					=> elem.style.display = ""

Свойство style.cssText соответствует всему атрибуту "style", полной строке стилей.
	elem.cssText перезависывает все css свойства
	добавление новых стилей к существующим стилям elem, используем +=
	elem.style.cssText += `
		top: ${top};
		left: ${left};
	`;

Для чтения окончательных стилей (Только для чтения)
	getComputedStyle(elem, [pseudo])
	Для правильного получения значения нужно указать точное свойство.
	Например: paddingLeft, marginTop, borderTopWidth.

? Атрибуты =================//

Когда браузер загружает страницу, он парсит HTML и генерирует из него DOM-объекты.
Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов.
DOM-свойства и методы ведут себя так же, как и обычные объекты JavaScript:
	Им можно присвоить любое значение.
	Они регистрозависимы (нужно писать elem.nodeType, не elem.NoDeTyPe).

hasAttribute('name')					Проверить наличие Атрибута
getAttribute('name')					Получить значение Атрибута
setAttribute('name', 'value')	Установить значение Атрибута
removeAttribute('name')				Удалить Атрибут
elem.attributes								Получить коллекцию всех атрибутов

Все атрибуты, в том числе те, которые мы установили, видны в outerHTML.
Коллекция attributes является перебираемой (for of).
В ней есть все атрибуты элемента в виде объектов со свойствами name и value.

У HTML-атрибутов есть следующие особенности:
	Их имена регистронезависимы (id то же самое, что и ID).
	Их значения всегда являются строками.

Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами.
Они доступны в свойстве dataset.
Например, если у elem есть атрибут "data-about", то обратиться к нему можно как elem.dataset.about.
Например, data-order-state становятся: dataset.orderState.

//* Размеры и прокрутка окна ================================================================================//

? Размеры
document.documentElement.clientWidth		Ширина видимой части документа (без полосы прокрутки)
document.documentElement.clientHeight		Высота видимой части документа (без полосы прокрутки)
document.innerWidth											Ширина документа (с полосой прокрутки)
document.innerHeight										Высота документа (с полосой прокрутки)

Ширина/высота всего документа со всей прокручиваемой областью страницы:
let scrollHeight = Math.max(
	document.body.scrollHeight, document.documentElement.scrollHeight,
	document.body.offsetHeight, document.documentElement.offsetHeight,
	document.body.clientHeight, document.documentElement.clientHeight
);

? Прокрутка
window.pageYOffset							получить прокрутку окна сверху (только для чтения)
window.pageXOffset							получить прокрутку окна слева (только для чтения)

Изменить текущую прокрутку:
window.scrollTo(pageX,pageY)		абсолютные координаты
window.scrollBy(x,y)						прокрутка относительно текущего места
elem.scrollIntoView(top)				прокрутить страницу так, чтобы сделать elem видимым (выровнять относительно верхней/нижней части окна).
	top или true - прокрутка к верхей части (по умолчанию)
	false - прокрутка к нижней части

? Метрики
offsetParent										ближайший CSS-позиционированный родитель или ближайший td, th, table, body.
offsetLeft/offsetTop						позиция в пикселях верхнего левого угла относительно offsetParent.
offsetWidth/offsetHeight				«внешняя» ширина/высота элемента, включая рамки.
clientLeft/clientTo							расстояние от верхнего левого внешнего угла до внутренного.
	Для операционных систем с ориентацией слева-направо эти свойства равны ширинам левой/верхней рамки.
	Если язык ОС таков, что ориентация справа налево, так что вертикальная полоса прокрутки находится не справа, а слева, то clientLeft включает в своё значение её ширину.
clientWidth/clientHeight				ширина/высота содержимого вместе с внутренними отступами padding, но без полосы прокрутки.
scrollWidth/scrollHeight				ширины/высота содержимого, аналогично clientWidth/Height, но учитывают прокрученную, невидимую область элемента.
scrollLeft/scrollTop						ширина/высота прокрученной сверху части элемента, считается от верхнего левого угла.
Все свойства доступны только для чтения, кроме scrollLeft/scrollTop, изменение которых заставляет браузер прокручивать элемент.

Любая точка на странице имеет координаты:
elem.getBoundingClientRect()		координаты относительно окна браузера
elem.getBoundingClientRect()		относительно документа плюс текущая прокрутка страницы.
Координаты в контексте окна подходят для использования с position:fixed,
	а координаты относительно документа – для использования с position:absolute.

 todo ====================================================================================================//
 todo ====================================================================================================//

! Браузерные события =====================================================================================//

Есть три способа назначения обработчиков событий:
Атрибут HTML: onclick="...".
DOM-свойство: elem.onclick = function.

Специальные методы:
elem.addEventListener(event, handler[, phase]) для добавления,removeEventListener для удаления.
event - Имя события, например "click".
handler - Ссылка на функцию-обработчик.
options - Дополнительный объект со свойствами:
	once: если true, тогда обработчик будет автоматически удалён после выполнения.
	capture: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе Всплытие и погружение. Так исторически сложилось, что options может быть false/true, это то же самое, что {capture: false/true}.
	passive: если true, то указывает, что обработчик никогда не вызовет preventDefault(), подробнее об этом будет рассказано в главе Действия браузера по умолчанию.

	element.addEventListener('click', addClass, { 'once': true }) // Выполнится только 1 раз

? События мыши:
click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
mouseover / mouseout – когда мышь наводится на / покидает элемент.
mouseenter / mouseleave - Как mouseover / mouseout, но пререходы внутри элемента на его потомков не считаются. mouseenter / mouseleave не всплывают!
mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
mousemove – при движении мыши.

Координаты относительно окна: clientX/clientY. (event.clientX / event.clientY)
Координаты относительно документа: pageX/pageY.

? События клавиатуры:
keydown - нажатие
keyup - птпускание
event.code; название клавиши
event.key;  название клавиши с учетом регистра (g G) или языка

Клавиши-модификаторы (true если нажаты): altKey, ctrlKey, shiftKey и metaKey (Mac).
Если вы планируете обработать Ctrl, то не забудьте, что пользователи Mac обычно используют Cmd,
поэтому лучше проверить if (e.metaKey || e.ctrlKey).

автоповтор при зажатии клавиши event.repeat вернет true

? Дрегие события:
scroll - это событие, когда пользователь прокручивает страницу или элемент в любой плоскости
DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен. Навешивается только на document
load - как DOMContentLoaded, но после загрузки стилей.  Навешивается только на window
submit – пользователь отправил форму <form>.
focus – пользователь фокусируется на элементе, например нажимает на <input>.
transitionend – когда CSS-анимация завершена.


//* Всплытие и погружение ==================================================================================//

При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target).
Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики,
поставленные через addEventListener(...., true), где true – это сокращение для {capture: true}.
Далее обработчики вызываются на целевом элементе.
Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики,
 поставленные через on<event> и addEventListener без третьего аргумента или с третьим аргументом равным false.

Каждый обработчик имеет доступ к свойствам события event:
event.target – самый глубокий элемент, на котором произошло событие.
event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
event.eventPhase – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).

Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется,
так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

//* Деллегирование событий ==================================================================================//

Алгоритм:
Вешаем обработчик на контейнер.
В обработчике проверяем исходный элемент event.target.
Если событие произошло внутри нужного нам элемента, то обрабатываем его.

Зачем использовать:
Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения innerHTML и ему подобных.

Конечно, у делегирования событий есть свои ограничения:
Во-первых, событие должно всплывать. Некоторые события этого не делают.
Также, низкоуровневые обработчики не должны вызывать event.stopPropagation().
Во-вторых, делегирование создаёт дополнительную нагрузку на браузер, ведь обработчик запускается,
когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны.
Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.


!  ====================================================================================================//


















*/