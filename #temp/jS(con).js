// https://learn.javascript.ru/ ====================================================================================================//

//* Типы данных=============================================================================================//
{/* (https://developer.mozilla.org/ru/docs/Web/JavaScript/Language_overview)
В JavaScript есть 8 основных типов данных.
Семь из них называют «примитивными» типами данных:

number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
bigint для целых чисел произвольной длины.
string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
boolean для true/false.
null для неизвестных значений – отдельный тип, имеющий одно значение null.
undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
symbol для уникальных идентификаторов.
object для более сложных структур данных, не является «примитивным» и стоит особняком

Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.
Имеет две формы: typeof x или typeof(x).
Возвращает строку с именем типа. Например, "string".
Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.
*/}

//* Преобразование типов ===================================================================================//
{/*
Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.

Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value).
Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).

Преобразование подчиняется правилам:
Значение	Становится…
undefined	NaN
null	0
true / false	1 / 0
string	Пробельные символы по краям обрезаются.
Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число.
При ошибке результат NaN.

Логическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).
Подчиняется правилам:
Значение	Становится…
0, null, undefined, NaN, "" - false
любое другое значение - true

Большую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:
undefined при численном преобразовании становится NaN, не 0.
"0" и строки из одних пробелов типа " " при логическом преобразовании всегда true.
*/}

//*Числа =============================================================================================//
/*
Math.floor(5.8)									Округлить вверх
Math.ceil(5.8)									Округлить вниз
Math.round(5.8)								 	Округлить до целого
Math.trunc											Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
Math.random()										Рандом
Math.max(5, 85, -49); 					Ищет максимум
Math.min(5, 85, -49); 					Ищет минимум
Math.pow(5, 8);									Возвести в степень
1.005 + Number.EPSILON					Компенсировать погрешности
Num.toFixed(1); 								кол-во знаков после запятой (как Math.round). Возвращает строку!!!
Number(string) 									Привести к числу. Или +"356"
.parseInt(Number) 							вернет ЦЕЛОЕ число из строки до текста. В качастве аргумента - система исчисления!!!
.parseFloat(Number) 						вернет число из строки до текста c цифрами после запятой. В качастве аргумента - система исчисления!!!
Number.isNaN()									проверка на NaN
Number.isInteger()							проверка на целое число
Number.isFinite(value)					преобразует аргумент в число и проверяет, что оно не является NaN/Infinity/-Infinity

Чтобы писать числа с большим количеством нулей:
Используйте краткую форму записи чисел – "e", с указанным количеством нулей. Например: 123e6 это 123 с 6-ю нулями 123000000.
Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей. Например: 123e-6 это 0.000123 (123 миллионных).

Для дробей:
Используйте округления Math.floor, Math.ceil, Math.trunc, Math.round или num.toFixed(precision).
Помните, что при работе с дробями происходит потеря точности.
*/

//* Строки =============================================================================================//
/*
string.lenght 										возвращает длину строки
string.charAt(5) 									возвращает символ под индексом 5
string.substring(5) 							возвращает c 5 символа и до конца string.substring(5, 10) 10- конец
string.slice(-10) 								возвращает как и substring, но может и с конца
string.substr(14, 4) 							возвращает как и substring, 4 - колличество символов
string.indexOf('word') 						ищет позицию слова или символы в строке
string.lastIndexOf('word') 				ищет позицию слова или символы в строке с конца
string.replace('word', 'another word') меняет строку (не перезаписывая) 'word' - что меняем, 'another word' - на что меняем. Только первое совпадение
string.replaceAll									меняет все совпадения
string.includes('ord') 						возвращает true or false
string.split(' ') 								принимает разделитель и разбивает строку на масив
arr.join(' ') 										создаёт строку из элементов arr, вставляя ' ' между ними
string.toUpperCase() 							приведение к верхнему регистру
string.toLowerCase() 							приведение к нижнему регистру
string[4] 												вернет 4 символnum.
toString 													Привести к строке. Или (345 + ""). В качастве аргумента - система исчисления!!!
'*'.repeat(4)											Повторить символ (4) раза
string.startsWith(str) 						проверяет начинается ли строка определённой строкой
string.endsWith(str)							проверяет заканчивается ли строка определённой строкой
string.trim()											обрезает пробелы (trimStart - в начале, trimEnd - в конце)
Boolean('string or expression')		приведение к булевому значению или !!('string or expression')
string.padStart (padEnd)					дополняет начало текущей строки другой строкой (при необходимости несколько раз) до заданной длины.
																	Первым параметром в методе указываем желаемую длину строки, а вторым необязательным - строку, которой она будет заполнена.

indexOf стоит использовать тогда когда нам нужна позиция найденой подстроки.
В остальных случаях удобнее использовать includes
Для получения символа используйте [] или метод at.
Для получения подстроки используйте slice или substring.
Для поиска подстроки используйте indexOf или includes/startsWith/endsWith, когда надо только проверить, есть ли вхождение.
Чтобы сравнить строки с учётом правил языка, используйте localeCompare.
*/

//* Объекты =================================================================================================//

/*
Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
Чтобы получить доступ к свойству, мы можем использовать:
Запись через точку: obj.property.
Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
Объекты присваиваются и копируются по ссылке.
Другими словами, переменная хранит не «значение объекта», а «ссылку» (адрес в памяти) на это значение.
Таким образом, копирование такой переменной или передача её в качестве аргумента функции копирует эту ссылку, а не сам объект.
Все операции с использованием скопированных ссылок (например, добавление/удаление свойств) выполняются с одним и тем же объектом.
Чтобы создать «реальную копию» (клон), мы можем использовать Object.assign для так называемой «поверхностной копии» 
(вложенные объекты копируются по ссылке) или функцию «глубокого клонирования», такую как _.cloneDeep(obj).

Object.hasOwnProperty								Возвращает true, только если данное свойство присутствует в объекте или его прототипе.
'key' in object											Возвращает true, только если данное свойство присутствует в объекте или его прототипе. Он предпочтительней когда неизвестен тип данных (null, undefined)
JSON.stringify(Object)							Преобразовать в строку (не конвертирует значения undefined (с null работает))
JSON.parse(String)									Преобразовать в объект
Object.keys(user)										Получить ключи в массив (первого уровня вложенности)
Object.values(user)									Получить значения в массив (первого уровня вложенности)
Object.entries(user)								Получить значения и ключи в массив масивов
Object.assign({}, user)							Копирование объекта (не глубокое!!!)
user?.address?.street								Опциональная цепочка (проверяет наличие ключа или возвращает undefinded) (let html = document.querySelector('.elem')?.innerHTML;)

///?Пройтись по ключам и вставить в переменную i  (for..in)
for (let i in user) { // положет ключи в i
	console.log(i)						ключ
	console.log(user[i])			значение
}

///?Вывести все ключи и значения циклом (Конвертировать объект в масив и работаем как с масивом)
const entries = Object.entries(user);
for (let i = 0; i < entries.length; i++) {
	const entry = entries[i];
	const key = entry[0];
	const value = entry[1];
	console.log(key, value);
}
*/

//* Массив ==================================================================================================//

{/*
	Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.
	Получение элементов:
	Мы можем получить элемент по его индексу, например arr[0].
	Также мы можем использовать метод at(i) для получения элементов с отрицательным индексом, для отрицательных значений i, он отступает от конца массива.
	В остальном он работает так же, как arr[i], если i >= 0.

	//?Мы можем использовать массив как двустороннюю очередь, используя следующие операции:
	push(...items)												добавляет items в конец массива.
	pop()																	удаляет элемент в конце массива и возвращает его.
	unshift(...items)											добавляет items в начало массива.
	shift()																удаляет элемент в начале массива и возвращает его.

	splice(pos, deleteCount, ...items)		начиная с индекса pos удаляет deleteCount элементов и вставляет items.
	slice(start, end)											создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
	concat(...items)											возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. 
																				Если какой-то из items является массивом, тогда берутся его элементы.

	//?Для поиска среди элементов:
	indexOf/lastIndexOf(item, pos)				ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено. .lastIndexOf() Ищет последнее вхождение элемента в массиве
	includes(value)												возвращает true, если в массиве имеется элемент value, в противном случае false. Работает только для простых данных
	find/filter(func)											фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
	some(func)														фильтрует элементы через функцию и вернет true или false
	findIndex 														похож на find, но возвращает индекс вместо значения.

	//?Для перебора элементов:
	forEach(func) – вызывает func для каждого элемента. Ничего не возвращает (нет continue и break).

	//?Чтобы пройтись по элементам массива:
	for (let i=0; i<arr.length; i++)			работает быстрее всего, совместим со старыми браузерами.
	for (let item of arr)									современный синтаксис только для значений элементов (к индексам нет доступа).
	for (let i in arr)										никогда не используйте для массивов!

	//?Для преобразования массива:
	arr.map(func)													создаёт новый массив из результатов вызова func для каждого элемента.
	arr.sort(func)												сортирует массив «на месте», а потом возвращает его.
	arr.reverse()													«на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
	string.split(' ')											разбивает строку на массив по заданному разделителю (как join, только в другую сторону)
	arr.join(' ')													склеивает массив в строку по заданному разделителю (как split, только в другую сторону)
	reduce/reduceRight(func, initial)			вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.
	arr.flat()														преобразует вложенные массивы в один. arr.flat(2) преобразовать вторую вложенность arr.flat(infinity)
	arr.reverse														разворачивает массив

	Array.isArray(arr) проверяет, является ли arr массивом.
	методы sort, reverse и splice изменяют исходный массив.

	//? Метод map()
	Позволяет трансформировать один массив в другой при помощи функций-колбэка.
	Переданная функция будет вызвана для каждого элемента массива по порядку.
	Из результатов вызова функции будет собран новый массив. Колличество новых элементов будет равно кол. старых эл. (изменить нельзя!!!)
	При работе с map() необходимо возвращать значение из функции-колбэка.
	Если не вернуть значение — например, забыв обработать какую-то ветку условия, то в итоговом массиве будет undefined
	В отличии от forEach возвращает результат вызова

		const arr = ['hi', 'hello']
		const newArr = arr.map(function (element) {
			return element.length		// Получаем новый массив из длин элементов оригинального [2, 5]
		})

	//? Метод filter()
	Позволяет получить новый массив, отфильтровав элементы с помощью переданной колбэк-функции.
	Колбэк-функция будет вызвана для каждого элемента массива и по результату функции примет решение включать этот элемент в новый массив или нет.
	Аналогично методу .forEach(), методу .filter() необходимо передать аргументом функцию.
	Главное отличие — функция должна возвращать boolean, т. е. результатом должен быть true или false. Такие функции называют предикатами.
	От результата выполнения функции зависит, попадёт ли элемент в итоговый массив: true — элемент попадёт в итоговый массив. false — нет.
	filter в опличии от map не меняет структуру массива, а меняет колличество элементов!!!
	filter() возвращает новый массив, при этом исходный массив никак не изменится.
	Если явно не указать return, то метод вернет пустой массив.

	//? Метод find() 
	В отличии от filter() вернёт первый найденный в массиве элемент, который подходит под условие в переданной колбэк-функции.
	Если в массиве не найдётся ни одного подходящего элемента, то вернётся значение undefined.

	//? Метод some()
	Позволяет узнать, есть ли в массиве хотя бы один элемент, удовлетворяющий условию в функции-колбэке.
	Результатом вызова метода some() будет boolean-значение true или false.
	Если ни один элемент в массиве не удовлетворит условию, то результат будет false.

	//? Метод reduce()
	Позволяет превратить массив в любой другой тип данных с помощью переданной функции-колбэка и начального значения.
	Функция-колбэк будет вызвана для каждого элемента массива, и всегда должна возвращать результат.
	Главной особенностью reduce(), которую важно запомнить, является наличие аккумулятора.

		const myArray = [1, 2, 3, 4, 5, 6, 7]
		const sumOfNumbers = myArray.reduce(
			// acc - аккумулятор, element - элемент массива
			function (acc, element) {
				return acc + element
			},
			0 // Начальное значение аккумулятора
		)
*/}

//* Деструктуризация =======================================================================================//
/*
Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.
	? В объектах выжены названия ключей
const { user_name, user_age } = { user_name: 'Alex', user_age: 19 }
	? Переименование ключей объектов
const { user_name: userName, user_age: userAge } = { user_name: 'Alex', user_age: 19 }
	? Переименование + значения по умолчанию
const { user_name: userName = 'unknown' } = { user_name: 'Alex', user_age: 19 }
	? В массивах важен порядок
const [one, two, three, four] = [1, 2, 3, 4]
	? Значания по умолчанию (без него - undefined)
const [userName = 'User', userAge = 18, hasCar = false] = [, ,]
*/

//* Планирование: setTimeout и setInterval =========================================//
/*
setTimeout() позволяет исполнить функцию через указанный промежуток времени.
setInterval() позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
	Функции возвращают числовой идентификатор установленного таймера.
	Этот идентификатор можно передать в функцию clearTimeout()/clearInterval(), чтобы остановить таймер.

setTimeout()/setInterval() принимает два аргумента:
	функция, которая выполнится, когда таймер закончится;
	время таймера в миллисекундах.

clearTimeout/clearInterval - останавливают setTimeout/setTimeout. В качестве аргумента - id таймера

Создание таймеров происходит синхронно
Функция внутри таймера выполняется асинхронно

Вложенный вызов setTimeout является более гибкой альтернативой setInterval.
Также он позволяет более точно задать интервал между выполнениями.
*/
// todo ====================================================================================================//
// todo ====================================================================================================//

//* Условное ветвление: if, '?' ============================================================================//

{/*
Иногда нам нужно выполнить различные действия в зависимости от условий.
Для этого мы можем использовать инструкцию if и условный оператор ?

if (age < 3) {
  message = 'Здравствуй, малыш!';
} else if (age < 18) {
  message = 'Привет!';
} else if (age < 100) {
  message = 'Здравствуйте!';
} else {
  message = 'Какой необычный возраст!';
}

Оператор „?“

Синтаксис:
let result = условие ? значение1 : значение2;

let age = prompt('Возраст?', 18);
let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';
alert( message );

Первый знак вопроса проверяет age < 3.
Если верно – возвращает 'Здравствуй, малыш!'. В противном случае, проверяет выражение после двоеточия „:“, вычисляет age < 18.
Если это верно – возвращает 'Привет!'. В противном случае, проверяет выражение после следующего двоеточия „:“, вычисляет age < 100.
Если это верно – возвращает 'Здравствуйте!'. В противном случае, возвращает выражение после последнего двоеточия – 'Какой необычный возраст!'.
*/}


//! Циклы ====================================================================================================//

{
	//* Циклы while и for ======================================================================================//

	{/*
while – Проверяет условие перед каждой итерацией.
while (condition) {
  // код
  // также называемый "телом цикла"
}

do..while – Проверяет условие после каждой итерации.
do {
  // тело цикла
} while (condition);

for (;;) – Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.
Чтобы организовать бесконечный цикл, используют конструкцию while (true).
При этом он, как и любой другой цикл, может быть прерван директивой break.
for (начало; условие; шаг) {
  // ... тело цикла ...
}

Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву continue.
Директива break полностью прекращает выполнение цикла и передаёт управление на строку за его телом.
Обе этих директивы поддерживают метки, которые ставятся перед циклом.

Метки – единственный способ для break/continue выйти за пределы текущего цикла, повлиять на выполнение внешнего.
Заметим, что метки не позволяют прыгнуть в произвольное место кода, в JavaScript нет такой возможности.
*/}

	//* Цикл "for..in" =========================================================================================//

	{/*
Для перебора всех свойств объекта используется цикл for..in.

let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
*/}
}

//* Функции ================================================================================================//
/*
? Function Declaration:
Function Declaration может быть вызвана раньше, чем она объявлена.
В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.

function имя(параметры, через, запятую) {
	тело, код функции
}

Параметр – это переменная, указанная в круглых скобках в объявлении функции.
Аргумент – это значение, которое передаётся функции при её вызове.

? Function Expression:
Если функция была создана как часть выражения, то это “Function Expression”.
Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.

let sayHi = function() {
	alert( "Привет" );
};

? Arrow functions:
let sum = (a, b) => a + b;

Стрелочные функции:
Не имеют this.
Не имеют arguments.
Не могут быть вызваны с new.

?=======/

Передаваемые значения копируются в параметры функции и становятся локальными переменными.
Функции имеют доступ к внешним переменным.Но это работает только изнутри наружу.
Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.
Код вне функции не имеет доступа к её локальным переменным.
Функция может возвращать значение. Если этого не происходит, тогда результат равен undefined.
Для того, чтобы сделать код более чистым и понятным, рекомендуется использовать локальные переменные и параметры функций, не пользоваться внешними переменными.
Функция, которая получает параметры, работает с ними и затем возвращает результат, 
	гораздо понятнее функции, вызываемой без параметров, но изменяющей внешние переменные, что чревато побочными эффектами.

Функции – это значения. Они могут быть присвоены, скопированы или объявлены в любом месте кода.
Если функция объявлена как отдельная инструкция в основном потоке кода, то это “Function Declaration”.
Если функция была создана как часть выражения, то это “Function Expression”.
Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
Функции, объявленные при помощи Function Expression, создаются только когда поток выполнения достигает их.
В большинстве случаев, когда нам нужно объявить функцию, Function Declaration предпочтительнее, т.к функция будет видна до своего объявления в коде.
Это даёт нам больше гибкости в организации кода, и, как правило, делает его более читабельным.
Исходя из этого, мы должны использовать Function Expression только тогда, когда Function Declaration не подходит для нашей задачи.
	*/
//todo  ====================================================================================================//
//todo  ====================================================================================================//

//! DOM ====================================================================================================//

{
	{/*
	
	//? Получить Узел =================//
	
	<html> = document.documentElement
	<head> = document.head
	<body> = document.body

	Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.
	Есть два основных набора ссылок:

	Для всех узлов: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
	Проверить наличие узла: hasChildNodes (element.hasChildNodes())
	
	Только для узлов-элементов:
	parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.

	Для childNodes методы массивов не работают, т.к. это коллекция (использовать for...of). Коллекции живые.
// Перебрать коллекцию: for..of ; forEach
		const elem = document.querySelectorAll('li')
		for (const item of elem) {
			console.log(item)
		}

//? Поиск =================//

	Есть 6 основных методов поиска элементов в DOM:
	Метод										Ищет по...		Ищет внутри элемента?	Возвращает живую коллекцию?
	querySelector						CSS-selector						✔												-
	querySelectorAll				CSS-selector						✔												-
	getElementById							id									-												-
	getElementsByName					name									-												✔
	getElementsByTagName		tag or '*'							✔												✔
	getElementsByClassName	class										✔												✔

	Безусловно, наиболее часто используемыми в настоящее время являются методы querySelector и querySelectorAll, 
	но и методы getElement(s)By* могут быть полезны в отдельных случаях, а также встречаются в старом коде.

	Кроме того:
	Есть метод elem.matches(css), который проверяет, удовлетворяет ли элемент CSS-селектору.Возвращает true или false
	Метод elem.closest(css) ищет ближайшего по иерархии предка, соответствующему данному CSS-селектору. Сам элемент также включён в поиск.
	elemA.contains(elemB) проверяет наличие отношений между предком и потомком: вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB.
	
	//? Получить содержимое =================//
	
	innerHTML Внутреннее HTML-содержимое узла-элемента. Можно изменять.
	outerHTML Полный HTML узла-элемента. Запись в elem.outerHTML не меняет elem. Вместо этого она заменяет его во внешнем контексте.
	textContent Текст внутри элемента: HTML за вычетом всех <тегов>. Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.
	hidden Когда значение установлено в true, делает то же самое, что и CSS display:none. (elem.hidden = true)

	
	//? Методы для создания узлов: =================//
	
	document.createElement("tag") – создаёт элемент с заданным тегом,
	document.createTextNode(value) – создаёт текстовый узел (редко используется),
	elem.cloneNode(deep) – клонирует элемент, если deep==true, то со всеми дочерними элементами.

	Вставка и удаление:
	node.before(...nodes or strings) – вставляет прямо перед node,
	node.prepend(...nodes or strings) – вставляет в node в начало,
	node.append(...nodes or strings) – вставляет в node в конец,
	node.after(...nodes or strings) – вставляет сразу после node,
	node.replaceWith(...nodes or strings) – заменяет node.
	node.remove() – удаляет node.

	Если нужно вставить фрагмент HTML, то elem.insertAdjacentHTML(where, html) вставляет в зависимости от where:
	"beforebegin" – вставляет html прямо перед elem,
	"afterbegin" – вставляет html в elem в начало,
	"beforeend" – вставляет html в elem в конец,
	"afterend" – вставляет html сразу после elem.
	Также существуют похожие методы elem.insertAdjacentText и elem.insertAdjacentElement, они вставляют текстовые строки и элементы, но они редко используются.

	//? Css =================//
	
	Для управления классами существуют два DOM-свойства:
	className – строковое значение, удобно для управления всем набором классов.
	classList – объект с методами add/remove/toggle/contains, удобно для управления отдельными классами.

	Чтобы изменить стили:
	Свойство style является объектом со стилями в формате camelCase.
	Чтение и запись в него работают так же, как изменение соответствующих свойств в атрибуте "style".
	Свойство style.cssText соответствует всему атрибуту "style", полной строке стилей.

	block.hidden = 'true'; Показать/Скрыть элемент

	Для чтения окончательных стилей (с учётом всех классов, после применения CSS и вычисления окончательных значений) используется:
	Метод getComputedStyle(elem, [pseudo]) возвращает объект, похожий по формату на style. Только для чтения.

	//? Атрибуты =================//

	hasAttribute('name') - Проверить наличие Атрибута
	getAttribute('name') - Получить значение Атрибута
	setAttribute('name', 'value') - Установить значение Атрибута
	removeAttribute('name') - Удалить Атрибут

	Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами.
	Они доступны в свойстве dataset.
	Например, если у elem есть атрибут "data-about", то обратиться к нему можно как elem.dataset.about.
*/}

	//* Размеры и прокрутка окна ================================================================================//

	{/*
Размеры:
document.documentElement.clientWidth/Height - ширина/высота видимой части документа (ширина/высота области содержимого)
document.innerWidth - Ширина документа (с полосой прокрутки)
document.innerHeight - Высота документа (с полосой прокрутки)

Ширина/высота всего документа со всей прокручиваемой областью страницы:
let scrollHeight = Math.max(
	document.body.scrollHeight, document.documentElement.scrollHeight,
	document.body.offsetHeight, document.documentElement.offsetHeight,
	document.body.clientHeight, document.documentElement.clientHeight
);

Прокрутка:
Прокрутку окна можно получить так: window.pageYOffset/pageXOffset.

Изменить текущую прокрутку:
window.scrollTo(pageX,pageY) – абсолютные координаты,
window.scrollBy(x,y) – прокрутка относительно текущего места,
elem.scrollIntoView(top) – прокрутить страницу так, чтобы сделать elem видимым (выровнять относительно верхней/нижней части окна).
top или true - прокрутка к верхей части (по умолчанию)
false - прокрутка к нижней части
*/}

	//* Размеры, прокрутка элементов.Координаты =================================================================//

	{/*
У элементов есть следующие геометрические свойства (метрики):

offsetParent – ближайший CSS-позиционированный родитель или ближайший td, th, table, body.
offsetLeft/offsetTop – позиция в пикселях верхнего левого угла относительно offsetParent.
offsetWidth/offsetHeight – «внешняя» ширина/высота элемента, включая рамки.
clientLeft/clientTop – расстояние от верхнего левого внешнего угла до внутренного.
	Для операционных систем с ориентацией слева-направо эти свойства равны ширинам левой/верхней рамки.
	Если язык ОС таков, что ориентация справа налево, так что вертикальная полоса прокрутки находится не справа, а слева, то clientLeft включает в своё значение её ширину.
clientWidth/clientHeight – ширина/высота содержимого вместе с внутренними отступами padding, но без полосы прокрутки.
scrollWidth/scrollHeight – ширины/высота содержимого, аналогично clientWidth/Height, но учитывают прокрученную, невидимую область элемента.
scrollLeft/scrollTop – ширина/высота прокрученной сверху части элемента, считается от верхнего левого угла.
Все свойства доступны только для чтения, кроме scrollLeft/scrollTop, изменение которых заставляет браузер прокручивать элемент.

Любая точка на странице имеет координаты:
Относительно окна браузера – elem.getBoundingClientRect().
Относительно документа – elem.getBoundingClientRect() плюс текущая прокрутка страницы.
Координаты в контексте окна подходят для использования с position:fixed, а координаты относительно документа – для использования с position:absolute.
*/}
}

// todo ====================================================================================================//
// todo ====================================================================================================//

//! Браузерные события =====================================================================================//
{
	{/*
	Есть три способа назначения обработчиков событий:
	Атрибут HTML: onclick="...".
	DOM-свойство: elem.onclick = function.

Специальные методы: 
	elem.addEventListener(event, handler[, phase]) для добавления,removeEventListener для удаления.
	event - Имя события, например "click".
	handler - Ссылка на функцию-обработчик.
	options - Дополнительный объект со свойствами:
		once: если true, тогда обработчик будет автоматически удалён после выполнения.
		capture: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе Всплытие и погружение. Так исторически сложилось, что options может быть false/true, это то же самое, что {capture: false/true}.
		passive: если true, то указывает, что обработчик никогда не вызовет preventDefault(), подробнее об этом будет рассказано в главе Действия браузера по умолчанию.

		element.addEventListener('click', addClass, { 'once': true }) // Выполнится только 1 раз

//?События мыши:
	click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
	contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
	mouseover / mouseout – когда мышь наводится на / покидает элемент.
	mouseenter / mouseleave - Как mouseover / mouseout, но пререходы внутри элемента на его потомков не считаются. mouseenter / mouseleave не всплывают!
	mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
	mousemove – при движении мыши.

	Координаты относительно окна: clientX/clientY. (event.clientX / event.clientY)
	Координаты относительно документа: pageX/pageY.

//?События клавиатуры:
	keydown - нажатие
	keyup - птпускание
	event.code; название клавиши
	event.key;  название клавиши с учетом регистра (g G) или языка

	Клавиши-модификаторы (true если нажаты): altKey, ctrlKey, shiftKey и metaKey (Mac).
	Если вы планируете обработать Ctrl, то не забудьте, что пользователи Mac обычно используют Cmd,
	поэтому лучше проверить if (e.metaKey || e.ctrlKey).

	автоповтор при зажатии клавиши event.repeat вернет true

//?Дрегие события:
	scroll - это событие, когда пользователь прокручивает страницу или элемент в любой плоскости
	DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен. Навешивается только на document
	load - как DOMContentLoaded, но после загрузки стилей.  Навешивается только на window
	submit – пользователь отправил форму <form>.
	focus – пользователь фокусируется на элементе, например нажимает на <input>.
	transitionend – когда CSS-анимация завершена.
*/}

	//* Всплытие и погружение ==================================================================================//

	{/*
При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target).
Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики,
поставленные через addEventListener(...., true), где true – это сокращение для {capture: true}.
Далее обработчики вызываются на целевом элементе.
Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики,
 поставленные через on<event> и addEventListener без третьего аргумента или с третьим аргументом равным false.

Каждый обработчик имеет доступ к свойствам события event:
event.target – самый глубокий элемент, на котором произошло событие.
event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
event.eventPhase – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).

Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется,
так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.
*/}

	//* Деллегирование событий ==================================================================================//

	{/*
Алгоритм:
Вешаем обработчик на контейнер.
В обработчике проверяем исходный элемент event.target.
Если событие произошло внутри нужного нам элемента, то обрабатываем его.

Зачем использовать:
Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения innerHTML и ему подобных.

Конечно, у делегирования событий есть свои ограничения:
Во-первых, событие должно всплывать. Некоторые события этого не делают.
Также, низкоуровневые обработчики не должны вызывать event.stopPropagation().
Во-вторых, делегирование создаёт дополнительную нагрузку на браузер, ведь обработчик запускается,
когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны.
Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.
*/}
}

//! ====================================================================================================//
//* Date ===============================================================================================//
/*
Date — класс для работы со временем. В основном используется для отображения и вычисления.(https://doka.guide/js/date/)
Время отображается в двух форматах:
	UTC — время по Гринвичу;
	В текущей часовой зоне (например, UTC+3 для Москвы).

? Создать новый экземпляр класса можно несколькими способами:
	new Date() создаёт экземпляр Date с текущей датой и временем.
	new Date(значение) создаёт Date с переданным значением времени.
		Значение должно быть в формате, который распознается методом Date.parse(), то есть быть совместимым с IETF RFC 2822 или с ISO8601.
		В формате ISO: new Date('YYYY-MM-DDTHH:mm:ss.sssZ')
		Здесь месяц начинается с 1. T - разделитель. Z - нулевое смещение (не учитывался часовой пояс)
	new Date(год, месяц, день, часы, минуты, секунды, миллисекунды) создаёт класс Date в местной часовой зоне.
		Год и месяц являются обязательными параметрами. Остальные параметры, начиная с часов, будут по умолчанию равны 0, а день — 1.
	new Date(миллисекунды) создаёт Date со временем в миллисекундах(Unix - формат).
		Количество миллисекунд измеряется с 1 января 1970 года UTC.

При установке месяца, отсчёт идёт с 0, где 0 — это январь.
При выводе дня недели возвращаемое значение также начинается с 0 и означает воскресенье.
Исключением из этого правила являются параметры, связанные с годом и днём месяца (первое число месяца — 1).

Есть два метода, которые не привязаны к часовой зоне:
	getTime() возвращает значение в миллисекундах, прошедших с 1 января 1970 года, соответствующее указанной дате по UTC.
	getTimezoneOffset() возвращает смещение в минутах между текущей часовой зоной и UTC.

? Получение текущего времени
Date.now() — метод, который возвращает текущее время в миллисекундах, прошедших с 1 января 1970 года UTC.
	Метод очень похож на new Date(), но, так как нет ключевого слова new, экземпляр класса не создаётся
	Возвращается только число: console.log(Date.now()) // 1661370397669
	Принимает значение в секундах. JS работает в милисекундах, поэтому *1000
	Используется для точного сравнения времени

? Математические операции необходимо выполнять со временем в формате UTC.
Обычные операции не учитывают летнее время часовых зон, поэтому результаты могут быть некорректны.

date.toISOString() - переконверт. в ISO формат
date.toDateString() - переконверт. более читаемый формат
date.toLocaleDateString('en') - переконверт. дату более читаемый формат с учетом языка страны
date.toLocaleTimeString('en') - переконверт. время более читаемый формат с учетом языка страны
date.toLocaleString('en') - переконверт. дату и время более читаемый формат с учетом языка страны


 ?Получить время и дату
 getFullYear()							возвращает год;
 getMonth()									возвращает месяц с 0 до 11;
 getDate()									возвращает день месяца с 1 до 31;
 getDay()										возвращает порядковый номер дня недели с 0(вс) до 6(сб)
 getHours()									возвращает часы с 0 до 23;
 getMinutes()								возвращает минуты от 0 до 59;
 getSeconds()								возвращает секунды от 0 до 59;
 getMilliseconds()					возвращает миллисекунды от 0 до 999.

Все вышеперечисленные методы возвращают значения для текущей часовой зоны.
Если необходимо вернуть время по Гринвичу, то нужно в метод добавить UTC:
getUTCFullYear(), getUTCMonth(), getUTCDate(), getUTCDay(), getUTCHours(), getUTCMinutes(),getUTCSeconds(), getUTCMilliseconds().

? Установка значений
Также, как и с получением значений, у многих методов есть присваивание значений в локальной часовой зоне и UTC.
Для локальной:

setFullYear(год, месяц, день)						устанавливает год, значения месяца и дня необязательны.
setMonth(месяц, день)										устанавливает месяц, передавать день необязательно.
setDate(день)														устанавливает день месяца.
setHours(часы, минуты, сек, миллисек)		устанавливает часы. Значения минут, секунд, миллисекунд необязательны.
setMinutes(минуты, сек, миллисек) -			устанавливает минуты. Секунды и миллисекунды необязательны.
setSeconds(сек, миллисек)								устанавливает секунды. Миллисекунды передавать необязательно.
setMilliseconds(миллисек) -							устанавливает миллисекунды.

Для UTC аналогичные методы, только добавляем UTC после set. Например, setUTCMilliseconds(миллисекунды).
И метод, который относится только к UTC:
setTime(значение) устанавливает значение, которое равно количеству миллисекунд, прошедших с 1 января 1970 года.
*/

//!  ====================================================================================================//
//!  ====================================================================================================//
//* Promise =============================================================================================//
/*
Промис (Promise) — специальный объект JavaScript, который используется для написания и обработки асинхронного кода.

Интерфейс Promise (промис) представляет собой обёртку для значения, неизвестного на момент создания промиса.
Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными:
вместо конечного результата асинхронного метода возвращается своего рода обещание (дословный перевод слова "промис") получить результат в некоторый момент в будущем.

Асинхронные функции возвращают объект Promise в качестве значения.
Внутри промиса хранится результат вычисления, которое может быть уже выполнено или выполнится в будущем.

Промис может находиться в одном из трёх состояний:
	pending   — стартовое состояние, операция стартовала;
	fulfilled — получен результат;
	rejected  — ошибка.

Методы, которые позволяют работать с результатом выполнения вычисления внутри промиса:
	then()								выполнить код после успешного выполнения асинхронной операции.
	catch()								выполнить код в случае ошибки при выполнении асинхронной операции.
	finally()							выполнить код вне зависимости от успеха выполнения.

Методы Промисов:
	Promise.all						ждем все промисы, если хоть один с ошибок - catch, иначе then
	Promise.allSettled		просто ждем выполнения всех промисов (всегда then)
	Promise.race					получаем первый выполнившийся промис (если он был с ошибкой - catch, иначе then)
	Promise.any						получаем первый УСПЕШНО выполнившийся промис

	let numbers = new Promise((resolve, reject) => {
	setTimeout(() => {
		const data = ['one', 'two', 'three']
		const data = 'sjkdv'
		if (Array.isArray(data)) {
			resolve(data)
		} else {
			reject('error!!!')
		}
	}, 1000)
})
numbers
	.then((data) => {
		console.log(data)
	})
	.catch((message) => {
		console.log(message)
	})
*/

//* API ====================================================================================================//
/* (https://doka.guide/tools/web-app-works/)
API (Application Programming Interface) — это набор фич, которые одна программа представляет всем остальным.
API может использоваться не только для общения браузера и сервера, но и в принципе для общения разных программ друг с другом.

REST (Representational State Transfer) — стиль общения компонентов, при котором все необходимые данные указываются в параметрах запроса.
REST сейчас — один из самых распространённых стилей API в интернете.
Всё взаимодействие между клиентом и сервером сводится к 4 операциям (CRUD):
	созданию чего-либо, например, объекта пользователя (create, C);
	чтению (read, R);
	обновлению (update, U);
	удалению (delete, D).

SOAP (Simple Object Access Protocol) — формат обмена данными.
Это структурированный формат обмена данными, то есть каждое сообщение следует определённой структуре.
Чаще всего вместе с SOAP используется XML для отражения этой структуры.
SOAP неважно, каким методом передавать сообщения, в отличие от REST.
Структура выглядит так:
	Envelope — корневой элемент, который определяет само сообщение.
	Header содержит атрибуты сообщения, например: информацию о безопасности.
	Body содержит сообщение, которым обмениваются приложения.
	Fault необязательный элемент с ошибками обработки, если они были.

AJAX (Asynchronous JavaScript and XML) — общение между клиентом и сервером без перезагрузки страницы.

MVC (Model-View-Controller) — структура приложения, в которой за данные, их обработку и их вывод отвечают три разных сущности.
Модель (model) отвечает за данные и их структуру.
Представление (view) — за их отображение.
Контроллер (controller) — за их обработку.

JSON — один из самых популярных форматов данных. Он немногословен, понятен и человеку, и компьютеру, много языков с ним уже умеют работать.
В вебе JSON, можно сказать, стандарт, потому что используется как формат по умолчанию во многих фреймворках.

fetch()
На уровне приложения мы используем встроенное браузерное API, а именно — fetch().
Это глобальный метод для отправки запросов.

const response = await fetch('/api/save-text', {
	method: 'POST',
	body: JSON.stringify(State),
})

Поле method — это так называемый HTTP-глагол.
HTTP-методы:
	POST для создания;
	GET для чтения;
	PUT обновляет объект целиком;
	DELETE для удаления.

HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) работает с текстовыми сообщениями,
	которые пересылаются от клиента к серверу (HTTP-запрос) и обратно (HTTP-ответ).
Структура сообщения следующая:
	Стартовая строка (Starting line) говорит нам, запрос или ответ содержит сообщение;
	Заголовки (Headers) описывают тело сообщения, параметры передачи и прочие сведения;
	Тело сообщения (Message Body) содержит данные.
HTTP был разработан как протокол обмена данными между веб-сервером и веб-браузером.
Код состояния в ответе сервера содержит информацию о результате обработки данных.
Существует пять классов кодов состояний:

	1xx — обработка данных на сервере продолжается;
	2xx — успешная обработка данных;
	3xx — перенаправление запросов;
	4xx — ошибка по вине клиента;
	5xx — ошибка по вине сервера.
*/

//* import/export ====================================================================================================//
/*
? Именованные экспорты
Внутри модулей всегда используется строгий режим (use strict)
При использовании ключевого слова export рядом с функцией или переменной,
	мы экспортируем конкретную функцию или переменную.
У таких переменных и функций обязательно должно быть имя,
	потому что именно по этому имени мы будем получать доступ к ним из других модулей.
Поэтому такие экспорты называются именованными.
У экспортируемой функциональности есть имя и по этому же имени мы будем импортировать её в других модулях.

export
	export const a = 5
export нескольких
	export {a, b, c}

	import
import { a } from "./test";
	import нескольких
import { a, b ,c } from "./test"; 

Переименование
	import { a as b } from "./test";
Переименование нескольких
	import { a as b, f as t } from "./test";

? Экспорты по умолчанию.
Когда мы из модуля экспортируем какую-то функциональность по умолчанию, мы можем опустить имя,
	но обязаны использовать ключевое слово default после export
Рекомендуем использовать именованные экспорты вместо экспортов по умолчанию там, где это возможно.
*/